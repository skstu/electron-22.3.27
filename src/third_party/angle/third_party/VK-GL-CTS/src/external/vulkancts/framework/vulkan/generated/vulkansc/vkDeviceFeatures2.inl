/* WARNING: This is auto-generated file. Do not modify, since changes will
 * be lost! Modify the generating script instead.
 * This file was generated by /scripts/gen_framework.py
 */

tcu::TestStatus testPhysicalDeviceFeature4444FormatsFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice4444FormatsFeaturesEXT	device4444FormatsFeaturesEXT[count];
	const bool								is4444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_4444_formats") || context.contextSupports(vk::ApiVersion(0, 1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device4444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
		device4444FormatsFeaturesEXT[ndx].sType = is4444FormatsFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		device4444FormatsFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device4444FormatsFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is4444FormatsFeaturesEXT)
		log << TestLog::Message << device4444FormatsFeaturesEXT[0] << TestLog::EndMessage;

	if (is4444FormatsFeaturesEXT &&
		(device4444FormatsFeaturesEXT[0].formatA4R4G4B4 != device4444FormatsFeaturesEXT[1].formatA4R4G4B4 ||
		 device4444FormatsFeaturesEXT[0].formatA4B4G4R4 != device4444FormatsFeaturesEXT[1].formatA4B4G4R4))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice4444FormatsFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature8BitStorageFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice8BitStorageFeatures	device8BitStorageFeatures[count];
	const bool							is8BitStorageFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device8BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice8BitStorageFeatures));
		device8BitStorageFeatures[ndx].sType = is8BitStorageFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		device8BitStorageFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device8BitStorageFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is8BitStorageFeatures)
		log << TestLog::Message << device8BitStorageFeatures[0] << TestLog::EndMessage;

	if (is8BitStorageFeatures &&
		(device8BitStorageFeatures[0].storageBuffer8BitAccess != device8BitStorageFeatures[1].storageBuffer8BitAccess ||
		 device8BitStorageFeatures[0].uniformAndStorageBuffer8BitAccess != device8BitStorageFeatures[1].uniformAndStorageBuffer8BitAccess ||
		 device8BitStorageFeatures[0].storagePushConstant8 != device8BitStorageFeatures[1].storagePushConstant8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice8BitStorageFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature16BitStorageFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice16BitStorageFeatures	device16BitStorageFeatures[count];
	const bool								is16BitStorageFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device16BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice16BitStorageFeatures));
		device16BitStorageFeatures[ndx].sType = is16BitStorageFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		device16BitStorageFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device16BitStorageFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is16BitStorageFeatures)
		log << TestLog::Message << device16BitStorageFeatures[0] << TestLog::EndMessage;

	if (is16BitStorageFeatures &&
		(device16BitStorageFeatures[0].storageBuffer16BitAccess != device16BitStorageFeatures[1].storageBuffer16BitAccess ||
		 device16BitStorageFeatures[0].uniformAndStorageBuffer16BitAccess != device16BitStorageFeatures[1].uniformAndStorageBuffer16BitAccess ||
		 device16BitStorageFeatures[0].storagePushConstant16 != device16BitStorageFeatures[1].storagePushConstant16 ||
		 device16BitStorageFeatures[0].storageInputOutput16 != device16BitStorageFeatures[1].storageInputOutput16))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice16BitStorageFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureASTCDecodeFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceASTCDecodeFeaturesEXT	deviceASTCDecodeFeaturesEXT[count];
	const bool								isASTCDecodeFeaturesEXT = checkExtension(properties, "VK_EXT_astc_decode_mode");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceASTCDecodeFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
		deviceASTCDecodeFeaturesEXT[ndx].sType = isASTCDecodeFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceASTCDecodeFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceASTCDecodeFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isASTCDecodeFeaturesEXT)
		log << TestLog::Message << deviceASTCDecodeFeaturesEXT[0] << TestLog::EndMessage;

	if (isASTCDecodeFeaturesEXT &&
		(deviceASTCDecodeFeaturesEXT[0].decodeModeSharedExponent != deviceASTCDecodeFeaturesEXT[1].decodeModeSharedExponent))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceASTCDecodeFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT	deviceBlendOperationAdvancedFeaturesEXT[count];
	const bool											isBlendOperationAdvancedFeaturesEXT = checkExtension(properties, "VK_EXT_blend_operation_advanced");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceBlendOperationAdvancedFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
		deviceBlendOperationAdvancedFeaturesEXT[ndx].sType = isBlendOperationAdvancedFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceBlendOperationAdvancedFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceBlendOperationAdvancedFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isBlendOperationAdvancedFeaturesEXT)
		log << TestLog::Message << deviceBlendOperationAdvancedFeaturesEXT[0] << TestLog::EndMessage;

	if (isBlendOperationAdvancedFeaturesEXT &&
		(deviceBlendOperationAdvancedFeaturesEXT[0].advancedBlendCoherentOperations != deviceBlendOperationAdvancedFeaturesEXT[1].advancedBlendCoherentOperations))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBufferDeviceAddressFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceBufferDeviceAddressFeatures	deviceBufferDeviceAddressFeatures[count];
	const bool									isBufferDeviceAddressFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceBufferDeviceAddressFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
		deviceBufferDeviceAddressFeatures[ndx].sType = isBufferDeviceAddressFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceBufferDeviceAddressFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceBufferDeviceAddressFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isBufferDeviceAddressFeatures)
		log << TestLog::Message << deviceBufferDeviceAddressFeatures[0] << TestLog::EndMessage;

	if (isBufferDeviceAddressFeatures &&
		(deviceBufferDeviceAddressFeatures[0].bufferDeviceAddress != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddress ||
		 deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressCaptureReplay != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressCaptureReplay ||
		 deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressMultiDevice != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressMultiDevice))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceBufferDeviceAddressFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceCustomBorderColorFeaturesEXT	deviceCustomBorderColorFeaturesEXT[count];
	const bool										isCustomBorderColorFeaturesEXT = checkExtension(properties, "VK_EXT_custom_border_color");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceCustomBorderColorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
		deviceCustomBorderColorFeaturesEXT[ndx].sType = isCustomBorderColorFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceCustomBorderColorFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceCustomBorderColorFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isCustomBorderColorFeaturesEXT)
		log << TestLog::Message << deviceCustomBorderColorFeaturesEXT[0] << TestLog::EndMessage;

	if (isCustomBorderColorFeaturesEXT &&
		(deviceCustomBorderColorFeaturesEXT[0].customBorderColors != deviceCustomBorderColorFeaturesEXT[1].customBorderColors ||
		 deviceCustomBorderColorFeaturesEXT[0].customBorderColorWithoutFormat != deviceCustomBorderColorFeaturesEXT[1].customBorderColorWithoutFormat))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceCustomBorderColorFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceColorWriteEnableFeaturesEXT	deviceColorWriteEnableFeaturesEXT[count];
	const bool									isColorWriteEnableFeaturesEXT = checkExtension(properties, "VK_EXT_color_write_enable");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceColorWriteEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
		deviceColorWriteEnableFeaturesEXT[ndx].sType = isColorWriteEnableFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceColorWriteEnableFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceColorWriteEnableFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isColorWriteEnableFeaturesEXT)
		log << TestLog::Message << deviceColorWriteEnableFeaturesEXT[0] << TestLog::EndMessage;

	if (isColorWriteEnableFeaturesEXT &&
		(deviceColorWriteEnableFeaturesEXT[0].colorWriteEnable != deviceColorWriteEnableFeaturesEXT[1].colorWriteEnable))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceColorWriteEnableFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDescriptorIndexingFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDescriptorIndexingFeatures	deviceDescriptorIndexingFeatures[count];
	const bool									isDescriptorIndexingFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDescriptorIndexingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
		deviceDescriptorIndexingFeatures[ndx].sType = isDescriptorIndexingFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDescriptorIndexingFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDescriptorIndexingFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDescriptorIndexingFeatures)
		log << TestLog::Message << deviceDescriptorIndexingFeatures[0] << TestLog::EndMessage;

	if (isDescriptorIndexingFeatures &&
		(deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderSampledImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderSampledImageArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageImageArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUniformBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingSampledImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingSampledImageUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageImageUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUpdateUnusedWhilePending != deviceDescriptorIndexingFeatures[1].descriptorBindingUpdateUnusedWhilePending ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingPartiallyBound != deviceDescriptorIndexingFeatures[1].descriptorBindingPartiallyBound ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingVariableDescriptorCount != deviceDescriptorIndexingFeatures[1].descriptorBindingVariableDescriptorCount ||
		 deviceDescriptorIndexingFeatures[0].runtimeDescriptorArray != deviceDescriptorIndexingFeatures[1].runtimeDescriptorArray))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDescriptorIndexingFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDepthClipEnableFeaturesEXT	deviceDepthClipEnableFeaturesEXT[count];
	const bool									isDepthClipEnableFeaturesEXT = checkExtension(properties, "VK_EXT_depth_clip_enable");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDepthClipEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
		deviceDepthClipEnableFeaturesEXT[ndx].sType = isDepthClipEnableFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDepthClipEnableFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDepthClipEnableFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDepthClipEnableFeaturesEXT)
		log << TestLog::Message << deviceDepthClipEnableFeaturesEXT[0] << TestLog::EndMessage;

	if (isDepthClipEnableFeaturesEXT &&
		(deviceDepthClipEnableFeaturesEXT[0].depthClipEnable != deviceDepthClipEnableFeaturesEXT[1].depthClipEnable))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDepthClipEnableFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceExtendedDynamicStateFeaturesEXT	deviceExtendedDynamicStateFeaturesEXT[count];
	const bool										isExtendedDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state") || context.contextSupports(vk::ApiVersion(0, 1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceExtendedDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
		deviceExtendedDynamicStateFeaturesEXT[ndx].sType = isExtendedDynamicStateFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceExtendedDynamicStateFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceExtendedDynamicStateFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isExtendedDynamicStateFeaturesEXT)
		log << TestLog::Message << deviceExtendedDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

	if (isExtendedDynamicStateFeaturesEXT &&
		(deviceExtendedDynamicStateFeaturesEXT[0].extendedDynamicState != deviceExtendedDynamicStateFeaturesEXT[1].extendedDynamicState))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicStateFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceExtendedDynamicState2FeaturesEXT	deviceExtendedDynamicState2FeaturesEXT[count];
	const bool											isExtendedDynamicState2FeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceExtendedDynamicState2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
		deviceExtendedDynamicState2FeaturesEXT[ndx].sType = isExtendedDynamicState2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceExtendedDynamicState2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceExtendedDynamicState2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isExtendedDynamicState2FeaturesEXT)
		log << TestLog::Message << deviceExtendedDynamicState2FeaturesEXT[0] << TestLog::EndMessage;

	if (isExtendedDynamicState2FeaturesEXT &&
		(deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2 != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2 ||
		 deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2LogicOp != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2LogicOp ||
		 deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2PatchControlPoints != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2PatchControlPoints))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicState2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentShadingRateFeaturesKHR	deviceFragmentShadingRateFeaturesKHR[count];
	const bool										isFragmentShadingRateFeaturesKHR = checkExtension(properties, "VK_KHR_fragment_shading_rate");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentShadingRateFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
		deviceFragmentShadingRateFeaturesKHR[ndx].sType = isFragmentShadingRateFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentShadingRateFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentShadingRateFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentShadingRateFeaturesKHR)
		log << TestLog::Message << deviceFragmentShadingRateFeaturesKHR[0] << TestLog::EndMessage;

	if (isFragmentShadingRateFeaturesKHR &&
		(deviceFragmentShadingRateFeaturesKHR[0].pipelineFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].pipelineFragmentShadingRate ||
		 deviceFragmentShadingRateFeaturesKHR[0].primitiveFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].primitiveFragmentShadingRate ||
		 deviceFragmentShadingRateFeaturesKHR[0].attachmentFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].attachmentFragmentShadingRate))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShadingRateFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureIndexTypeUint8FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceIndexTypeUint8FeaturesEXT	deviceIndexTypeUint8FeaturesEXT[count];
	const bool									isIndexTypeUint8FeaturesEXT = checkExtension(properties, "VK_EXT_index_type_uint8");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceIndexTypeUint8FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
		deviceIndexTypeUint8FeaturesEXT[ndx].sType = isIndexTypeUint8FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceIndexTypeUint8FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceIndexTypeUint8FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isIndexTypeUint8FeaturesEXT)
		log << TestLog::Message << deviceIndexTypeUint8FeaturesEXT[0] << TestLog::EndMessage;

	if (isIndexTypeUint8FeaturesEXT &&
		(deviceIndexTypeUint8FeaturesEXT[0].indexTypeUint8 != deviceIndexTypeUint8FeaturesEXT[1].indexTypeUint8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceIndexTypeUint8FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImagelessFramebufferFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceImagelessFramebufferFeatures	deviceImagelessFramebufferFeatures[count];
	const bool										isImagelessFramebufferFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceImagelessFramebufferFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
		deviceImagelessFramebufferFeatures[ndx].sType = isImagelessFramebufferFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceImagelessFramebufferFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceImagelessFramebufferFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isImagelessFramebufferFeatures)
		log << TestLog::Message << deviceImagelessFramebufferFeatures[0] << TestLog::EndMessage;

	if (isImagelessFramebufferFeatures &&
		(deviceImagelessFramebufferFeatures[0].imagelessFramebuffer != deviceImagelessFramebufferFeatures[1].imagelessFramebuffer))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceImagelessFramebufferFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureHostQueryResetFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceHostQueryResetFeatures	deviceHostQueryResetFeatures[count];
	const bool								isHostQueryResetFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceHostQueryResetFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceHostQueryResetFeatures));
		deviceHostQueryResetFeatures[ndx].sType = isHostQueryResetFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceHostQueryResetFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceHostQueryResetFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isHostQueryResetFeatures)
		log << TestLog::Message << deviceHostQueryResetFeatures[0] << TestLog::EndMessage;

	if (isHostQueryResetFeatures &&
		(deviceHostQueryResetFeatures[0].hostQueryReset != deviceHostQueryResetFeatures[1].hostQueryReset))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceHostQueryResetFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureLineRasterizationFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceLineRasterizationFeaturesEXT	deviceLineRasterizationFeaturesEXT[count];
	const bool										isLineRasterizationFeaturesEXT = checkExtension(properties, "VK_EXT_line_rasterization");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceLineRasterizationFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
		deviceLineRasterizationFeaturesEXT[ndx].sType = isLineRasterizationFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceLineRasterizationFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceLineRasterizationFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isLineRasterizationFeaturesEXT)
		log << TestLog::Message << deviceLineRasterizationFeaturesEXT[0] << TestLog::EndMessage;

	if (isLineRasterizationFeaturesEXT &&
		(deviceLineRasterizationFeaturesEXT[0].rectangularLines != deviceLineRasterizationFeaturesEXT[1].rectangularLines ||
		 deviceLineRasterizationFeaturesEXT[0].bresenhamLines != deviceLineRasterizationFeaturesEXT[1].bresenhamLines ||
		 deviceLineRasterizationFeaturesEXT[0].smoothLines != deviceLineRasterizationFeaturesEXT[1].smoothLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledRectangularLines != deviceLineRasterizationFeaturesEXT[1].stippledRectangularLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledBresenhamLines != deviceLineRasterizationFeaturesEXT[1].stippledBresenhamLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledSmoothLines != deviceLineRasterizationFeaturesEXT[1].stippledSmoothLines))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceLineRasterizationFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMultiviewFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceMultiviewFeatures	deviceMultiviewFeatures[count];
	const bool							isMultiviewFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceMultiviewFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMultiviewFeatures));
		deviceMultiviewFeatures[ndx].sType = isMultiviewFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceMultiviewFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceMultiviewFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isMultiviewFeatures)
		log << TestLog::Message << deviceMultiviewFeatures[0] << TestLog::EndMessage;

	if (isMultiviewFeatures &&
		(deviceMultiviewFeatures[0].multiview != deviceMultiviewFeatures[1].multiview ||
		 deviceMultiviewFeatures[0].multiviewGeometryShader != deviceMultiviewFeatures[1].multiviewGeometryShader ||
		 deviceMultiviewFeatures[0].multiviewTessellationShader != deviceMultiviewFeatures[1].multiviewTessellationShader))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceMultiviewFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePerformanceQueryFeaturesKHR	devicePerformanceQueryFeaturesKHR[count];
	const bool									isPerformanceQueryFeaturesKHR = checkExtension(properties, "VK_KHR_performance_query");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePerformanceQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
		devicePerformanceQueryFeaturesKHR[ndx].sType = isPerformanceQueryFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePerformanceQueryFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePerformanceQueryFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPerformanceQueryFeaturesKHR)
		log << TestLog::Message << devicePerformanceQueryFeaturesKHR[0] << TestLog::EndMessage;

	if (isPerformanceQueryFeaturesKHR &&
		(devicePerformanceQueryFeaturesKHR[0].performanceCounterQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterQueryPools ||
		 devicePerformanceQueryFeaturesKHR[0].performanceCounterMultipleQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterMultipleQueryPools))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePerformanceQueryFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureProtectedMemoryFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceProtectedMemoryFeatures	deviceProtectedMemoryFeatures[count];
	const bool								isProtectedMemoryFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceProtectedMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
		deviceProtectedMemoryFeatures[ndx].sType = isProtectedMemoryFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceProtectedMemoryFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceProtectedMemoryFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isProtectedMemoryFeatures)
		log << TestLog::Message << deviceProtectedMemoryFeatures[0] << TestLog::EndMessage;

	if (isProtectedMemoryFeatures &&
		(deviceProtectedMemoryFeatures[0].protectedMemory != deviceProtectedMemoryFeatures[1].protectedMemory))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceProtectedMemoryFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRobustness2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceRobustness2FeaturesEXT	deviceRobustness2FeaturesEXT[count];
	const bool								isRobustness2FeaturesEXT = checkExtension(properties, "VK_EXT_robustness2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceRobustness2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRobustness2FeaturesEXT));
		deviceRobustness2FeaturesEXT[ndx].sType = isRobustness2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceRobustness2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceRobustness2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isRobustness2FeaturesEXT)
		log << TestLog::Message << deviceRobustness2FeaturesEXT[0] << TestLog::EndMessage;

	if (isRobustness2FeaturesEXT &&
		(deviceRobustness2FeaturesEXT[0].robustBufferAccess2 != deviceRobustness2FeaturesEXT[1].robustBufferAccess2 ||
		 deviceRobustness2FeaturesEXT[0].robustImageAccess2 != deviceRobustness2FeaturesEXT[1].robustImageAccess2 ||
		 deviceRobustness2FeaturesEXT[0].nullDescriptor != deviceRobustness2FeaturesEXT[1].nullDescriptor))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceRobustness2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSamplerYcbcrConversionFeatures	deviceSamplerYcbcrConversionFeatures[count];
	const bool										isSamplerYcbcrConversionFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSamplerYcbcrConversionFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
		deviceSamplerYcbcrConversionFeatures[ndx].sType = isSamplerYcbcrConversionFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSamplerYcbcrConversionFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSamplerYcbcrConversionFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSamplerYcbcrConversionFeatures)
		log << TestLog::Message << deviceSamplerYcbcrConversionFeatures[0] << TestLog::EndMessage;

	if (isSamplerYcbcrConversionFeatures &&
		(deviceSamplerYcbcrConversionFeatures[0].samplerYcbcrConversion != deviceSamplerYcbcrConversionFeatures[1].samplerYcbcrConversion))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSamplerYcbcrConversionFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureScalarBlockLayoutFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceScalarBlockLayoutFeatures	deviceScalarBlockLayoutFeatures[count];
	const bool									isScalarBlockLayoutFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceScalarBlockLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
		deviceScalarBlockLayoutFeatures[ndx].sType = isScalarBlockLayoutFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceScalarBlockLayoutFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceScalarBlockLayoutFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isScalarBlockLayoutFeatures)
		log << TestLog::Message << deviceScalarBlockLayoutFeatures[0] << TestLog::EndMessage;

	if (isScalarBlockLayoutFeatures &&
		(deviceScalarBlockLayoutFeatures[0].scalarBlockLayout != deviceScalarBlockLayoutFeatures[1].scalarBlockLayout))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceScalarBlockLayoutFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures	deviceSeparateDepthStencilLayoutsFeatures[count];
	const bool											isSeparateDepthStencilLayoutsFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSeparateDepthStencilLayoutsFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
		deviceSeparateDepthStencilLayoutsFeatures[ndx].sType = isSeparateDepthStencilLayoutsFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSeparateDepthStencilLayoutsFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSeparateDepthStencilLayoutsFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSeparateDepthStencilLayoutsFeatures)
		log << TestLog::Message << deviceSeparateDepthStencilLayoutsFeatures[0] << TestLog::EndMessage;

	if (isSeparateDepthStencilLayoutsFeatures &&
		(deviceSeparateDepthStencilLayoutsFeatures[0].separateDepthStencilLayouts != deviceSeparateDepthStencilLayoutsFeatures[1].separateDepthStencilLayouts))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicInt64Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderAtomicInt64Features	deviceShaderAtomicInt64Features[count];
	const bool									isShaderAtomicInt64Features = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderAtomicInt64Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
		deviceShaderAtomicInt64Features[ndx].sType = isShaderAtomicInt64Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderAtomicInt64Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderAtomicInt64Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderAtomicInt64Features)
		log << TestLog::Message << deviceShaderAtomicInt64Features[0] << TestLog::EndMessage;

	if (isShaderAtomicInt64Features &&
		(deviceShaderAtomicInt64Features[0].shaderBufferInt64Atomics != deviceShaderAtomicInt64Features[1].shaderBufferInt64Atomics ||
		 deviceShaderAtomicInt64Features[0].shaderSharedInt64Atomics != deviceShaderAtomicInt64Features[1].shaderSharedInt64Atomics))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicInt64Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderAtomicFloatFeaturesEXT	deviceShaderAtomicFloatFeaturesEXT[count];
	const bool										isShaderAtomicFloatFeaturesEXT = checkExtension(properties, "VK_EXT_shader_atomic_float");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderAtomicFloatFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
		deviceShaderAtomicFloatFeaturesEXT[ndx].sType = isShaderAtomicFloatFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderAtomicFloatFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderAtomicFloatFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderAtomicFloatFeaturesEXT)
		log << TestLog::Message << deviceShaderAtomicFloatFeaturesEXT[0] << TestLog::EndMessage;

	if (isShaderAtomicFloatFeaturesEXT &&
		(deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32AtomicAdd))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicFloatFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderFloat16Int8Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderFloat16Int8Features	deviceShaderFloat16Int8Features[count];
	const bool									isShaderFloat16Int8Features = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderFloat16Int8Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
		deviceShaderFloat16Int8Features[ndx].sType = isShaderFloat16Int8Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderFloat16Int8Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderFloat16Int8Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderFloat16Int8Features)
		log << TestLog::Message << deviceShaderFloat16Int8Features[0] << TestLog::EndMessage;

	if (isShaderFloat16Int8Features &&
		(deviceShaderFloat16Int8Features[0].shaderFloat16 != deviceShaderFloat16Int8Features[1].shaderFloat16 ||
		 deviceShaderFloat16Int8Features[0].shaderInt8 != deviceShaderFloat16Int8Features[1].shaderInt8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderFloat16Int8Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderClockFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderClockFeaturesKHR	deviceShaderClockFeaturesKHR[count];
	const bool								isShaderClockFeaturesKHR = checkExtension(properties, "VK_KHR_shader_clock");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderClockFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
		deviceShaderClockFeaturesKHR[ndx].sType = isShaderClockFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderClockFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderClockFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderClockFeaturesKHR)
		log << TestLog::Message << deviceShaderClockFeaturesKHR[0] << TestLog::EndMessage;

	if (isShaderClockFeaturesKHR &&
		(deviceShaderClockFeaturesKHR[0].shaderSubgroupClock != deviceShaderClockFeaturesKHR[1].shaderSubgroupClock ||
		 deviceShaderClockFeaturesKHR[0].shaderDeviceClock != deviceShaderClockFeaturesKHR[1].shaderDeviceClock))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderClockFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDrawParametersFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderDrawParametersFeatures	deviceShaderDrawParametersFeatures[count];
	const bool										isShaderDrawParametersFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderDrawParametersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
		deviceShaderDrawParametersFeatures[ndx].sType = isShaderDrawParametersFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderDrawParametersFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderDrawParametersFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderDrawParametersFeatures)
		log << TestLog::Message << deviceShaderDrawParametersFeatures[0] << TestLog::EndMessage;

	if (isShaderDrawParametersFeatures &&
		(deviceShaderDrawParametersFeatures[0].shaderDrawParameters != deviceShaderDrawParametersFeatures[1].shaderDrawParameters))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDrawParametersFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures	deviceShaderSubgroupExtendedTypesFeatures[count];
	const bool											isShaderSubgroupExtendedTypesFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderSubgroupExtendedTypesFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
		deviceShaderSubgroupExtendedTypesFeatures[ndx].sType = isShaderSubgroupExtendedTypesFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderSubgroupExtendedTypesFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderSubgroupExtendedTypesFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderSubgroupExtendedTypesFeatures)
		log << TestLog::Message << deviceShaderSubgroupExtendedTypesFeatures[0] << TestLog::EndMessage;

	if (isShaderSubgroupExtendedTypesFeatures &&
		(deviceShaderSubgroupExtendedTypesFeatures[0].shaderSubgroupExtendedTypes != deviceShaderSubgroupExtendedTypesFeatures[1].shaderSubgroupExtendedTypes))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT	deviceFragmentShaderInterlockFeaturesEXT[count];
	const bool											isFragmentShaderInterlockFeaturesEXT = checkExtension(properties, "VK_EXT_fragment_shader_interlock");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentShaderInterlockFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
		deviceFragmentShaderInterlockFeaturesEXT[ndx].sType = isFragmentShaderInterlockFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentShaderInterlockFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentShaderInterlockFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentShaderInterlockFeaturesEXT)
		log << TestLog::Message << deviceFragmentShaderInterlockFeaturesEXT[0] << TestLog::EndMessage;

	if (isFragmentShaderInterlockFeaturesEXT &&
		(deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderSampleInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderSampleInterlock ||
		 deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderPixelInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderPixelInterlock ||
		 deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderShadingRateInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderShadingRateInterlock))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT	deviceTexelBufferAlignmentFeaturesEXT[count];
	const bool										isTexelBufferAlignmentFeaturesEXT = checkExtension(properties, "VK_EXT_texel_buffer_alignment");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTexelBufferAlignmentFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
		deviceTexelBufferAlignmentFeaturesEXT[ndx].sType = isTexelBufferAlignmentFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTexelBufferAlignmentFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTexelBufferAlignmentFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTexelBufferAlignmentFeaturesEXT)
		log << TestLog::Message << deviceTexelBufferAlignmentFeaturesEXT[0] << TestLog::EndMessage;

	if (isTexelBufferAlignmentFeaturesEXT &&
		(deviceTexelBufferAlignmentFeaturesEXT[0].texelBufferAlignment != deviceTexelBufferAlignmentFeaturesEXT[1].texelBufferAlignment))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTimelineSemaphoreFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTimelineSemaphoreFeatures	deviceTimelineSemaphoreFeatures[count];
	const bool									isTimelineSemaphoreFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTimelineSemaphoreFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
		deviceTimelineSemaphoreFeatures[ndx].sType = isTimelineSemaphoreFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTimelineSemaphoreFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTimelineSemaphoreFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTimelineSemaphoreFeatures)
		log << TestLog::Message << deviceTimelineSemaphoreFeatures[0] << TestLog::EndMessage;

	if (isTimelineSemaphoreFeatures &&
		(deviceTimelineSemaphoreFeatures[0].timelineSemaphore != deviceTimelineSemaphoreFeatures[1].timelineSemaphore))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTimelineSemaphoreFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceUniformBufferStandardLayoutFeatures	deviceUniformBufferStandardLayoutFeatures[count];
	const bool											isUniformBufferStandardLayoutFeatures = context.contextSupports(vk::ApiVersion(0, 1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceUniformBufferStandardLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
		deviceUniformBufferStandardLayoutFeatures[ndx].sType = isUniformBufferStandardLayoutFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceUniformBufferStandardLayoutFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceUniformBufferStandardLayoutFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isUniformBufferStandardLayoutFeatures)
		log << TestLog::Message << deviceUniformBufferStandardLayoutFeatures[0] << TestLog::EndMessage;

	if (isUniformBufferStandardLayoutFeatures &&
		(deviceUniformBufferStandardLayoutFeatures[0].uniformBufferStandardLayout != deviceUniformBufferStandardLayoutFeatures[1].uniformBufferStandardLayout))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceUniformBufferStandardLayoutFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVariablePointersFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVariablePointersFeatures	deviceVariablePointersFeatures[count];
	const bool									isVariablePointersFeatures = context.contextSupports(vk::ApiVersion(0, 1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVariablePointersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVariablePointersFeatures));
		deviceVariablePointersFeatures[ndx].sType = isVariablePointersFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVariablePointersFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVariablePointersFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVariablePointersFeatures)
		log << TestLog::Message << deviceVariablePointersFeatures[0] << TestLog::EndMessage;

	if (isVariablePointersFeatures &&
		(deviceVariablePointersFeatures[0].variablePointersStorageBuffer != deviceVariablePointersFeatures[1].variablePointersStorageBuffer ||
		 deviceVariablePointersFeatures[0].variablePointers != deviceVariablePointersFeatures[1].variablePointers))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVariablePointersFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexAttributeDivisorFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT	deviceVertexAttributeDivisorFeaturesEXT[count];
	const bool											isVertexAttributeDivisorFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_attribute_divisor");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVertexAttributeDivisorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
		deviceVertexAttributeDivisorFeaturesEXT[ndx].sType = isVertexAttributeDivisorFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVertexAttributeDivisorFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVertexAttributeDivisorFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVertexAttributeDivisorFeaturesEXT)
		log << TestLog::Message << deviceVertexAttributeDivisorFeaturesEXT[0] << TestLog::EndMessage;

	if (isVertexAttributeDivisorFeaturesEXT &&
		(deviceVertexAttributeDivisorFeaturesEXT[0].vertexAttributeInstanceRateDivisor != deviceVertexAttributeDivisorFeaturesEXT[1].vertexAttributeInstanceRateDivisor ||
		 deviceVertexAttributeDivisorFeaturesEXT[0].vertexAttributeInstanceRateZeroDivisor != deviceVertexAttributeDivisorFeaturesEXT[1].vertexAttributeInstanceRateZeroDivisor))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT	deviceVertexInputDynamicStateFeaturesEXT[count];
	const bool											isVertexInputDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_input_dynamic_state");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVertexInputDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
		deviceVertexInputDynamicStateFeaturesEXT[ndx].sType = isVertexInputDynamicStateFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVertexInputDynamicStateFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVertexInputDynamicStateFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVertexInputDynamicStateFeaturesEXT)
		log << TestLog::Message << deviceVertexInputDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

	if (isVertexInputDynamicStateFeaturesEXT &&
		(deviceVertexInputDynamicStateFeaturesEXT[0].vertexInputDynamicState != deviceVertexInputDynamicStateFeaturesEXT[1].vertexInputDynamicState))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceYcbcrImageArraysFeaturesEXT	deviceYcbcrImageArraysFeaturesEXT[count];
	const bool									isYcbcrImageArraysFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_image_arrays");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceYcbcrImageArraysFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
		deviceYcbcrImageArraysFeaturesEXT[ndx].sType = isYcbcrImageArraysFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceYcbcrImageArraysFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceYcbcrImageArraysFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isYcbcrImageArraysFeaturesEXT)
		log << TestLog::Message << deviceYcbcrImageArraysFeaturesEXT[0] << TestLog::EndMessage;

	if (isYcbcrImageArraysFeaturesEXT &&
		(deviceYcbcrImageArraysFeaturesEXT[0].ycbcrImageArrays != deviceYcbcrImageArraysFeaturesEXT[1].ycbcrImageArrays))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcrImageArraysFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT	deviceYcbcr2Plane444FormatsFeaturesEXT[count];
	const bool											isYcbcr2Plane444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_2plane_444_formats");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceYcbcr2Plane444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
		deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].sType = isYcbcr2Plane444FormatsFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceYcbcr2Plane444FormatsFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isYcbcr2Plane444FormatsFeaturesEXT)
		log << TestLog::Message << deviceYcbcr2Plane444FormatsFeaturesEXT[0] << TestLog::EndMessage;

	if (isYcbcr2Plane444FormatsFeaturesEXT &&
		(deviceYcbcr2Plane444FormatsFeaturesEXT[0].ycbcr2plane444Formats != deviceYcbcr2Plane444FormatsFeaturesEXT[1].ycbcr2plane444Formats))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}


void addSeparateFeatureTests (tcu::TestCaseGroup* testGroup)
{

	addFunctionCase(testGroup, "4444_formats_features_ext", "VkPhysicalDevice4444FormatsFeaturesEXT", testPhysicalDeviceFeature4444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "8_bit_storage_features", "VkPhysicalDevice8BitStorageFeatures", testPhysicalDeviceFeature8BitStorageFeatures);
	addFunctionCase(testGroup, "16_bit_storage_features", "VkPhysicalDevice16BitStorageFeatures", testPhysicalDeviceFeature16BitStorageFeatures);
	addFunctionCase(testGroup, "astc_decode_features_ext", "VkPhysicalDeviceASTCDecodeFeaturesEXT", testPhysicalDeviceFeatureASTCDecodeFeaturesEXT);
	addFunctionCase(testGroup, "blend_operation_advanced_features_ext", "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features", "VkPhysicalDeviceBufferDeviceAddressFeatures", testPhysicalDeviceFeatureBufferDeviceAddressFeatures);
	addFunctionCase(testGroup, "custom_border_color_features_ext", "VkPhysicalDeviceCustomBorderColorFeaturesEXT", testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT);
	addFunctionCase(testGroup, "color_write_enable_features_ext", "VkPhysicalDeviceColorWriteEnableFeaturesEXT", testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT);
	addFunctionCase(testGroup, "descriptor_indexing_features", "VkPhysicalDeviceDescriptorIndexingFeatures", testPhysicalDeviceFeatureDescriptorIndexingFeatures);
	addFunctionCase(testGroup, "depth_clip_enable_features_ext", "VkPhysicalDeviceDepthClipEnableFeaturesEXT", testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state_features_ext", "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state2_features_ext", "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT", testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT);
	addFunctionCase(testGroup, "fragment_shading_rate_features_khr", "VkPhysicalDeviceFragmentShadingRateFeaturesKHR", testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR);
	addFunctionCase(testGroup, "index_type_uint8_features_ext", "VkPhysicalDeviceIndexTypeUint8FeaturesEXT", testPhysicalDeviceFeatureIndexTypeUint8FeaturesEXT);
	addFunctionCase(testGroup, "imageless_framebuffer_features", "VkPhysicalDeviceImagelessFramebufferFeatures", testPhysicalDeviceFeatureImagelessFramebufferFeatures);
	addFunctionCase(testGroup, "host_query_reset_features", "VkPhysicalDeviceHostQueryResetFeatures", testPhysicalDeviceFeatureHostQueryResetFeatures);
	addFunctionCase(testGroup, "line_rasterization_features_ext", "VkPhysicalDeviceLineRasterizationFeaturesEXT", testPhysicalDeviceFeatureLineRasterizationFeaturesEXT);
	addFunctionCase(testGroup, "multiview_features", "VkPhysicalDeviceMultiviewFeatures", testPhysicalDeviceFeatureMultiviewFeatures);
	addFunctionCase(testGroup, "performance_query_features_khr", "VkPhysicalDevicePerformanceQueryFeaturesKHR", testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR);
	addFunctionCase(testGroup, "protected_memory_features", "VkPhysicalDeviceProtectedMemoryFeatures", testPhysicalDeviceFeatureProtectedMemoryFeatures);
	addFunctionCase(testGroup, "robustness2_features_ext", "VkPhysicalDeviceRobustness2FeaturesEXT", testPhysicalDeviceFeatureRobustness2FeaturesEXT);
	addFunctionCase(testGroup, "sampler_ycbcr_conversion_features", "VkPhysicalDeviceSamplerYcbcrConversionFeatures", testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures);
	addFunctionCase(testGroup, "scalar_block_layout_features", "VkPhysicalDeviceScalarBlockLayoutFeatures", testPhysicalDeviceFeatureScalarBlockLayoutFeatures);
	addFunctionCase(testGroup, "separate_depth_stencil_layouts_features", "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures);
	addFunctionCase(testGroup, "shader_atomic_int64_features", "VkPhysicalDeviceShaderAtomicInt64Features", testPhysicalDeviceFeatureShaderAtomicInt64Features);
	addFunctionCase(testGroup, "shader_atomic_float_features_ext", "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT);
	addFunctionCase(testGroup, "shader_float16_int8_features", "VkPhysicalDeviceShaderFloat16Int8Features", testPhysicalDeviceFeatureShaderFloat16Int8Features);
	addFunctionCase(testGroup, "shader_clock_features_khr", "VkPhysicalDeviceShaderClockFeaturesKHR", testPhysicalDeviceFeatureShaderClockFeaturesKHR);
	addFunctionCase(testGroup, "shader_draw_parameters_features", "VkPhysicalDeviceShaderDrawParametersFeatures", testPhysicalDeviceFeatureShaderDrawParametersFeatures);
	addFunctionCase(testGroup, "shader_subgroup_extended_types_features", "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures);
	addFunctionCase(testGroup, "fragment_shader_interlock_features_ext", "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT);
	addFunctionCase(testGroup, "texel_buffer_alignment_features_ext", "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT);
	addFunctionCase(testGroup, "timeline_semaphore_features", "VkPhysicalDeviceTimelineSemaphoreFeatures", testPhysicalDeviceFeatureTimelineSemaphoreFeatures);
	addFunctionCase(testGroup, "uniform_buffer_standard_layout_features", "VkPhysicalDeviceUniformBufferStandardLayoutFeatures", testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures);
	addFunctionCase(testGroup, "variable_pointers_features", "VkPhysicalDeviceVariablePointersFeatures", testPhysicalDeviceFeatureVariablePointersFeatures);
	addFunctionCase(testGroup, "vertex_attribute_divisor_features_ext", "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", testPhysicalDeviceFeatureVertexAttributeDivisorFeaturesEXT);
	addFunctionCase(testGroup, "vertex_input_dynamic_state_features_ext", "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT", testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "ycbcr_image_arrays_features_ext", "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT);
	addFunctionCase(testGroup, "ycbcr2_plane444_formats_features_ext", "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT", testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT);
}

