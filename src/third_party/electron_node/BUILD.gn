import("//v8/gni/v8.gni")
import("node.gni")

declare_args() {
  # Enable the V8 inspector protocol for use with node.
  node_enable_inspector = true

  # Build node with SSL support.
  # The variable is called "openssl" for parity with node's GYP build.
  node_use_openssl = true

  # Use the specified path to system CA (PEM format) in addition to
  # the BoringSSL supplied CA store or compiled-in Mozilla CA copy.
  node_openssl_system_ca_path = ""

  # Initialize v8 platform during node.js startup.
  # NB. this must be turned off in Electron, because Electron initializes the
  # v8 platform itself.
  node_use_v8_platform = false

  # Build with DTrace support.
  node_use_dtrace = false

  # Build with ETW support.
  node_use_etw = false

  # Build JavaScript in lib/ with DCHECK macros.
  node_debug_lib = false

  # Custom build tag.
  node_tag = ""

  # V8 options to pass, see `node --v8-options` for examples
  node_v8_options = ""

  # Provide a custom URL prefix for the `process.release` properties
  # `sourceUrl` and `headersUrl`. When compiling a release build, this will
  # default to https://nodejs.org/download/release/')
  node_release_urlbase = ""

  # Allows embedders to override the NODE_MODULE_VERSION define
  node_module_version = ""

  # Allows downstream packagers (eg. Linux distributions) to build Electron against system shared libraries.
  use_system_cares = false
  use_system_nghttp2 = false
  use_system_llhttp = false
  use_system_histogram = false
}

if (is_linux) {
 import("//build/config/linux/pkg_config.gni")
 if (use_system_cares) {
  pkg_config("cares") {
    packages = [ "libcares" ]
  }
 }
 if (use_system_nghttp2) {
  pkg_config("nghttp2") {
    packages = [ "libnghttp2" ]
  }
 }
}

assert(!node_use_dtrace, "node_use_dtrace not supported in GN")
assert(!node_use_etw, "node_use_etw not supported in GN")

assert(!node_enable_inspector || node_use_openssl,
       "node_enable_inspector requires node_use_openssl")

config("node_internals") {
  defines = [ "NODE_WANT_INTERNALS=1" ]
}

node_files = read_file("filenames.json", "json")
library_files = node_files.library_files

copy("node_js2c_inputs") {
  sources = library_files
  outputs = [
    "$target_gen_dir/js2c_inputs/{{source_target_relative}}",
  ]
}

chdir_action("node_js2c") {
  deps = [
    "//electron:generate_config_gypi",
    ":node_js2c_inputs",
  ]
  config_gypi = [ "$root_gen_dir/config.gypi" ]
  inputs = library_files + config_gypi
  outputs = [
    "$target_gen_dir/node_javascript.cc",
  ]

  cwd = "$target_gen_dir/js2c_inputs"
  script = "tools/js2c.py"
  args = library_files + rebase_path(config_gypi) + ["--target"] + rebase_path(outputs)
}

config("node_features") {
  defines = []
  if (node_enable_inspector) {
    defines += [ "HAVE_INSPECTOR=1" ]
  } else {
    defines += [ "HAVE_INSPECTOR=0" ]
  }
  if (node_use_openssl) {
    defines += [ "HAVE_OPENSSL=1" ]
  } else {
    defines += [ "HAVE_OPENSSL=0" ]
  }
  if (v8_enable_i18n_support) {
    defines += [ "NODE_HAVE_I18N_SUPPORT=1" ]
  } else {
    defines += [ "NODE_HAVE_I18N_SUPPORT=0" ]
  }
  if (node_use_v8_platform) {
    defines += [ "NODE_USE_V8_PLATFORM=1" ]
  } else {
    defines += [ "NODE_USE_V8_PLATFORM=0" ]
  }
}

config("node_lib_config") {
  include_dirs = [ "src" ]

  # FIXME(deepak1556): include paths should be corrected,
  # refer https://docs.google.com/presentation/d/1oxNHaVjA9Gn_rTzX6HIpJHP7nXRua_0URXxxJ3oYRq0/edit#slide=id.g71ecd450e_2_702
  cflags = [ "-Wno-microsoft-include" ]

  configs = [ ":node_features" ]

  if (is_debug) {
    defines = [ "DEBUG" ]
  }
}

config("node_internal_config") {
  visibility = [
    ":*",
    "src/inspector:*",
  ]
  defines = [
    "NODE_WANT_INTERNALS=1",
    "NODE_IMPLEMENTATION",
  ]
  if (node_module_version != "") {
    defines += [ "NODE_MODULE_VERSION=" + node_module_version ]
  }
  if (is_component_build) {
    defines += [
      "NODE_SHARED_MODE",
    ]
  }

  if (target_cpu == "x86") {
    node_arch = "ia32"
  } else {
    node_arch = target_cpu
  }
  defines += [ "NODE_ARCH=\"$node_arch\"" ]

  if (target_os == "win") {
    node_platform = "win32"
  } else if (target_os == "mac") {
    node_platform = "darwin"
  } else {
    node_platform = target_os
  }
  defines += [ "NODE_PLATFORM=\"$node_platform\"" ]

  if (is_win) {
    defines += [
      "NOMINMAX",
      "_UNICODE=1",
    ]
  } else {
    defines += [ "__POSIX__" ]
  }

  if (node_tag != "") {
    defines += [ "NODE_TAG=\"$node_tag\"" ]
  }
  if (node_v8_options != "") {
    defines += [ "NODE_V8_OPTIONS=\"$node_v8_options\"" ]
  }
  if (node_release_urlbase != "") {
    defines += [ "NODE_RELEASE_URLBASE=\"$node_release_urlbase\"" ]
  }

  if (node_use_openssl) {
    defines += [
      "NODE_OPENSSL_SYSTEM_CERT_PATH=\"$node_openssl_system_ca_path\"",
      "EVP_CTRL_CCM_SET_TAG=EVP_CTRL_GCM_SET_TAG",
    ]
  }
}

executable("overlapped-checker") {
  sources = []
  if (is_win) {
    sources += [ "test/overlapped-checker/main_win.c" ]
  } else {
    sources += [ "test/overlapped-checker/main_unix.c" ]
  }
}

component("node_lib") {
  deps = [
    ":node_js2c",
    "deps/googletest:gtest",
    "deps/uvwasi",
    "//third_party/zlib",
    "//third_party/brotli:dec",
    "//third_party/brotli:enc",
    "//v8:v8_libplatform",
  ]
  if (use_system_cares) {
    configs += [ ":cares" ]
  } else {
    deps += [ "deps/cares" ]
  }
  if (use_system_nghttp2) {
    configs += [ ":nghttp2" ]
  } else {
    deps += [ "deps/nghttp2" ]
  }
  public_deps = [
    "deps/uv",
    "//electron:electron_js2c",
    "//v8",
  ]
  configs += [ ":node_internal_config" ]
  public_configs = [ ":node_lib_config" ]
  include_dirs = [ "src" ]
  libs = []
  if (use_system_llhttp) {
    libs += [ "llhttp" ]
  } else {
    deps += [ "deps/llhttp" ]
  }
  if (use_system_histogram) {
    libs += [ "hdr_histogram" ]
    include_dirs += [ "/usr/include/hdr" ]
  } else {
    deps += [ "deps/histogram" ]
  }
  frameworks = []
  cflags_cc = [
    "-Wno-deprecated-declarations",
    "-Wno-implicit-fallthrough",
    "-Wno-return-type",
    "-Wno-sometimes-uninitialized",
    "-Wno-string-plus-int",
    "-Wno-unused-function",
    "-Wno-unused-label",
    "-Wno-unused-private-field",
    "-Wno-unused-variable",
    "-Wno-shadow",
  ]

  if (v8_enable_i18n_support) {
    deps += [ "//third_party/icu" ]
  }

  sources = node_files.node_sources
  sources += [
    "$root_gen_dir/electron_natives.cc",
    "$target_gen_dir/node_javascript.cc",
    "src/node_code_cache_stub.cc",
    "src/node_snapshot_stub.cc",
  ]

  if (is_win) {
    libs += [ "psapi.lib" ]
  }
  if (is_mac) {
    frameworks += [ "CoreFoundation.framework" ]
  }

  if (node_enable_inspector) {
    sources += [
      "src/inspector_agent.cc",
      "src/inspector_agent.h",
      "src/inspector_io.cc",
      "src/inspector_io.h",
      "src/inspector_js_api.cc",
      "src/inspector_profiler.cc",
      "src/inspector_socket.cc",
      "src/inspector_socket.h",
      "src/inspector_socket_server.cc",
      "src/inspector_socket_server.h",
    ]
    deps += [ "src/inspector" ]
  }

  if (node_use_openssl) {
    deps += [ "//third_party/boringssl" ]
    sources += [
      "src/crypto/crypto_aes.cc",
      "src/crypto/crypto_aes.h",
      "src/crypto/crypto_bio.cc",
      "src/crypto/crypto_bio.h",
      "src/crypto/crypto_cipher.cc",
      "src/crypto/crypto_cipher.h",
      "src/crypto/crypto_clienthello-inl.h",
      "src/crypto/crypto_clienthello.cc",
      "src/crypto/crypto_clienthello.h",
      "src/crypto/crypto_common.cc",
      "src/crypto/crypto_common.h",
      "src/crypto/crypto_context.cc",
      "src/crypto/crypto_context.h",
      "src/crypto/crypto_dh.cc",
      "src/crypto/crypto_dh.h",
      "src/crypto/crypto_dsa.cc",
      "src/crypto/crypto_dsa.h",
      "src/crypto/crypto_ec.cc",
      "src/crypto/crypto_ec.h",
      "src/crypto/crypto_groups.h",
      "src/crypto/crypto_hash.cc",
      "src/crypto/crypto_hash.h",
      "src/crypto/crypto_hkdf.cc",
      "src/crypto/crypto_hkdf.h",
      "src/crypto/crypto_hmac.cc",
      "src/crypto/crypto_hmac.h",
      "src/crypto/crypto_keygen.cc",
      "src/crypto/crypto_keygen.h",
      "src/crypto/crypto_keys.cc",
      "src/crypto/crypto_keys.h",
      "src/crypto/crypto_pbkdf2.cc",
      "src/crypto/crypto_pbkdf2.h",
      "src/crypto/crypto_random.cc",
      "src/crypto/crypto_random.h",
      "src/crypto/crypto_rsa.cc",
      "src/crypto/crypto_rsa.h",
      "src/crypto/crypto_scrypt.cc",
      "src/crypto/crypto_scrypt.h",
      "src/crypto/crypto_sig.cc",
      "src/crypto/crypto_sig.h",
      "src/crypto/crypto_spkac.cc",
      "src/crypto/crypto_spkac.h",
      "src/crypto/crypto_timing.cc",
      "src/crypto/crypto_timing.h",
      "src/crypto/crypto_tls.cc",
      "src/crypto/crypto_tls.h",
      "src/crypto/crypto_util.cc",
      "src/crypto/crypto_util.h",
      "src/crypto/crypto_x509.cc",
      "src/crypto/crypto_x509.h",
      "src/node_crypto.cc",
      "src/node_crypto.h",
    ]
    cflags_cc += [ "-Wno-sign-compare" ]
  }
}

##### node_headers

node_headers_dir = "$root_gen_dir/node_headers"

header_group_index = 0
header_groups = []
foreach(header_group, node_files.headers) {
  copy("node_headers_${header_group_index}") {
    sources = header_group.files
    outputs = [
      "$node_headers_dir/${header_group.dest_dir}/{{source_file_part}}",
    ]
  }
  header_groups += [ ":node_headers_${header_group_index}" ]
  header_group_index += 1
}

copy("zlib_headers") {
  sources = [
    "deps/zlib/zconf.h",
    "deps/zlib/zlib.h",
  ]
  outputs = [
    "$node_headers_dir/include/node/{{source_file_part}}",
  ]
}

copy("node_gypi_headers") {
  deps = [
    "//electron:generate_config_gypi",
  ]
  sources = [
    "$root_gen_dir/config.gypi",
    "common.gypi",
  ]
  outputs = [
    "$node_headers_dir/include/node/{{source_file_part}}",
  ]
}

action("node_version_header") {
  inputs = [
    "src/node_version.h",
  ]
  outputs = [
    "$node_headers_dir/include/node/node_version.h",
  ]
  script = "tools/generate_node_version_header.py"
  args = [ rebase_path("src/node_version.h"), rebase_path(outputs[0]) ]
  if (node_module_version != "") {
    args += [ "$node_module_version" ]
  }
}

action("tar_headers") {
  deps = [
    ":copy_headers",
  ]
  outputs = [
    "$root_gen_dir/node_headers.tar.gz",
  ]
  script = "tools/tar.py"
  args = [
    rebase_path("$root_gen_dir/node_headers"),
    rebase_path(outputs[0]),
  ]
}

group("copy_headers") {
  public_deps = header_groups + [
                  ":zlib_headers",
                  ":node_gypi_headers",
                  ":node_version_header",
                ]
}

group("headers") {
  public_deps = [
    ":tar_headers",
  ]
}
