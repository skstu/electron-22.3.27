"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default('primary-interface');
exports.generatePrimaryInterfaces = (API, interfaceKeys, addToOutput) => {
    // Generate Main / Renderer process interfaces
    const CommonNamespace = ['namespace Common {'];
    const MainNamespace = ['namespace Main {'];
    const RendererNamespace = ['namespace Renderer {'];
    const MainInterfaceForRemote = ['interface RemoteMainInterface {'];
    const CrossProcessExportsNamespace = ['namespace CrossProcessExports {'];
    const constDeclarations = [];
    const EMRI = {};
    const classify = (moduleName) => {
        switch (moduleName.toLowerCase()) {
            case 'session':
                return 'session';
            case 'nativeimage':
                return 'nativeImage';
            case 'webcontents':
                return 'webContents';
            case 'webframemain':
                return 'webFrameMain';
            default:
                return moduleName;
        }
    };
    API.forEach((module, index) => {
        if (module.name === 'process')
            return;
        let TargetNamespace;
        const isClass = module.type === 'Class';
        if (module.type === 'Structure') {
            // We must be a structure or something
            return;
        }
        const moduleString = isClass
            ? module.process.exported
                ? `  class ${lodash_1.default.upperFirst(module.name)} extends Electron.${lodash_1.default.upperFirst(module.name)} {}`
                : `  type ${lodash_1.default.upperFirst(module.name)} = Electron.${lodash_1.default.upperFirst(module.name)}`
            : '';
        const newConstDeclarations = [];
        const newTypeAliases = [];
        // In the case where this module is actually the static methods on a Class type
        const isModuleButActuallyStaticClass = API.some((tModule, tIndex) => index !== tIndex &&
            tModule.name.toLowerCase() === module.name.toLowerCase() &&
            tModule.type === 'Class');
        if ((!isClass || module.name !== classify(module.name)) && module.process.exported) {
            if (isClass) {
                newConstDeclarations.push(`type ${classify(module.name)} = ${lodash_1.default.upperFirst(module.name)};`, `const ${classify(module.name)}: typeof ${lodash_1.default.upperFirst(module.name)};`);
            }
            else {
                if (isModuleButActuallyStaticClass && !isClass) {
                    newConstDeclarations.push(`const ${classify(module.name)}: typeof ${lodash_1.default.upperFirst(module.name)};`);
                }
                else {
                    newConstDeclarations.push(`const ${classify(module.name)}: ${lodash_1.default.upperFirst(module.name)};`);
                }
                newTypeAliases.push(`type ${lodash_1.default.upperFirst(module.name)} = Electron.${lodash_1.default.upperFirst(module.name)};`);
            }
        }
        constDeclarations.push(...newConstDeclarations);
        if (module.process.main && module.process.renderer) {
            TargetNamespace = CommonNamespace;
        }
        else if (module.process.main) {
            TargetNamespace = MainNamespace;
        }
        else if (module.process.renderer) {
            TargetNamespace = RendererNamespace;
        }
        if (module.process.main &&
            module.process.exported &&
            !EMRI[classify(module.name).toLowerCase()]) {
            MainInterfaceForRemote.push(`  ${classify(module.name)}: ${isClass || isModuleButActuallyStaticClass ? 'typeof ' : ''}${lodash_1.default.upperFirst(module.name)};`);
        }
        if (TargetNamespace) {
            debug(classify(module.name).toLowerCase(), EMRI[classify(module.name).toLowerCase()]);
            if (!EMRI[classify(module.name).toLowerCase()]) {
                if (moduleString)
                    TargetNamespace.push(moduleString);
                if (moduleString)
                    CrossProcessExportsNamespace.push(moduleString);
            }
            EMRI[classify(module.name).toLowerCase()] = true;
            const declarations = [...newConstDeclarations, ...newTypeAliases].map(s => `  ${s.substr(0, s.length - 1)}`);
            TargetNamespace.push(...declarations);
            CrossProcessExportsNamespace.push(...declarations);
        }
    });
    addToOutput([...MainInterfaceForRemote, '}']);
    for (const interfaceKey of interfaceKeys) {
        const alias = `  type ${interfaceKey} = Electron.${interfaceKey}`;
        CommonNamespace.push(alias);
        MainNamespace.push(alias);
        RendererNamespace.push(alias);
        CrossProcessExportsNamespace.push(alias);
    }
    CommonNamespace.push('}');
    MainNamespace.push('}');
    RendererNamespace.push('}');
    CrossProcessExportsNamespace.push('}');
    const withSemicolons = (lines) => {
        return lines.map(l => (l.endsWith('{') || l.endsWith('}') ? l : `${l};`));
    };
    addToOutput(['']);
    addToOutput(withSemicolons(CommonNamespace));
    addToOutput(withSemicolons(MainNamespace));
    addToOutput(withSemicolons(RendererNamespace));
    addToOutput(withSemicolons(CrossProcessExportsNamespace));
    addToOutput(constDeclarations);
};
//# sourceMappingURL=primary-interfaces.js.map