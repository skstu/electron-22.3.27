"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const utils = __importStar(require("./utils"));
const module_declaration_1 = require("./module-declaration");
const remap_optionals_1 = require("./remap-optionals");
const primary_interfaces_1 = require("./primary-interfaces");
const dynamic_param_interfaces_1 = require("./dynamic-param-interfaces");
// takes the predefined header and footer and wraps them around the generated files
const wrapWithHeaderAndFooter = (outputLines, electronVersion) => {
    const newOutputLines = [];
    utils.extendArray(newOutputLines, fs
        .readFileSync(path.resolve(__dirname, '../base/base_header.ts'), 'utf8')
        .replace('<<VERSION>>', electronVersion)
        .split(/\r?\n/));
    newOutputLines.push('declare namespace Electron {');
    utils.extendArray(newOutputLines, fs
        .readFileSync(path.resolve(__dirname, '../base/base_inner.ts'), 'utf8')
        .replace('<<VERSION>>', electronVersion)
        .split(/\r?\n/));
    outputLines.slice(0).forEach(l => newOutputLines.push(`${lodash_1.default.trimEnd(`  ${l}`)}`));
    utils.extendArray(newOutputLines, ['}', '']);
    utils.extendArray(newOutputLines, fs
        .readFileSync(path.resolve(__dirname, '../base/base_footer.ts'), 'utf8')
        .replace('<<VERSION>>', electronVersion)
        .split(/\r?\n/));
    return newOutputLines;
};
const appendNodeJSOverride = (outputLines) => {
    utils.extendArray(outputLines, ['', 'declare namespace NodeJS {']);
    const processAPI = module_declaration_1.getModuleDeclarations().Process;
    processAPI.push('}');
    utils.extendArray(outputLines, processAPI.map((l, index) => l.length ? (index === 0 || index === processAPI.length - 1 ? `  ${l}` : `    ${l}`) : ''));
    utils.extendArray(outputLines, [
        '  interface ProcessVersions {',
        '    readonly electron: string;',
        '    readonly chrome: string;',
        '  }',
    ]);
    utils.extendArray(outputLines, ['}']);
    return outputLines.join('\n');
};
function generateDefinitions({ electronApi: API }) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputLines = [];
        // adds lines to output with given indentation level
        const addToOutput = (lines, indentation) => {
            indentation = indentation || '';
            utils.extendArray(outputLines, lines
                .map((l, i) => (i === 0 || i >= lines.length - 1 ? l : `${l}${indentation}`))
                .concat(['\n']));
        };
        remap_optionals_1.remapOptionals(API);
        // generate module declaration for every class, module, structure, element, etc
        const declaredStructs = [];
        API.sort((m1, m2) => m1.name.localeCompare(m2.name)).forEach((module, index) => {
            if (module.type === 'Structure') {
                declaredStructs.push(module.name);
            }
            module_declaration_1.generateModuleDeclaration(module, index, API);
        });
        // fetch everything that's been made and pop it into the actual API
        Object.keys(module_declaration_1.getModuleDeclarations()).forEach(moduleKey => {
            if (moduleKey === 'Process')
                return;
            const moduleAPI = module_declaration_1.getModuleDeclarations()[moduleKey];
            moduleAPI.push('}');
            addToOutput(moduleAPI.map((l, index) => (index === 0 || index === moduleAPI.length - 1 ? l : `  ${l}`)));
        });
        const keys = dynamic_param_interfaces_1.DynamicParamInterfaces.flushParamInterfaces(API, addToOutput);
        primary_interfaces_1.generatePrimaryInterfaces(API, [...keys, ...declaredStructs], addToOutput);
        const electronOutput = wrapWithHeaderAndFooter(outputLines, API[0].version);
        return appendNodeJSOverride(electronOutput);
    });
}
exports.generateDefinitions = generateDefinitions;
//# sourceMappingURL=index.js.map