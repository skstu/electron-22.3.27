"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils = __importStar(require("./utils"));
const debug_1 = __importDefault(require("debug"));
const docs_parser_1 = require("@electron/docs-parser");
const chalk_1 = __importDefault(require("chalk"));
const debug = debug_1.default('dynamic-param');
// Object of interfaces we need to declare
const paramInterfacesToDeclare = {};
// Interfaces that we would declare with these prefixes should remove them before declaration
const impoliteInterfaceNames = ['Get', 'Set', 'Show'];
const polite = (s) => {
    for (let i = 0; i < impoliteInterfaceNames.length; i++) {
        if (s.startsWith(impoliteInterfaceNames[i]))
            return polite(s.substring(impoliteInterfaceNames[i].length));
    }
    return s;
};
// Ignore descriptions when comparing objects
const ignoreDescriptions = (props) => lodash_1.default.map(props, p => {
    const { description } = p, toReturn = __rest(p, ["description"]);
    return toReturn;
}).sort((a, b) => a.name.localeCompare(b.name));
// Given a parameter create a new interface and return it's name + array modifier
// IName is the proposed interface name prefix
// backupIName is a slightly longer IName in case IName is already taken
const createParamInterface = (param, IName = '', backupIName = '', finalBackupIName = '') => {
    const maybeArray = (type) => (param.collection ? `Array<${type}>` : type);
    let argType = polite(IName) + lodash_1.default.upperFirst(lodash_1.default.camelCase(param.name));
    let argName = param.name;
    // TODO: Note.  It is still possible for even backupIName to be already used
    let usingExistingParamInterface = false;
    lodash_1.default.forIn(paramInterfacesToDeclare, (value, key) => {
        const test = lodash_1.default.assign({}, param, { name: argName, tName: argType });
        if (lodash_1.default.isEqual(test, value)) {
            usingExistingParamInterface = true;
            debug(chalk_1.default.cyan(`Using existing type for param name ${argType} --> ${key} in Interface: ${lodash_1.default.upperFirst(param.tName)} --- This is because their structure is identical`));
            argType = key;
            return false;
        }
    });
    if (usingExistingParamInterface) {
        return maybeArray(argType);
    }
    if (paramInterfacesToDeclare[argType] &&
        !lodash_1.default.isEqual(ignoreDescriptions(paramInterfacesToDeclare[argType].properties), ignoreDescriptions(param.properties))) {
        if (backupIName) {
            return createParamInterface(param, backupIName, finalBackupIName);
        }
        console.error(argType, IName, backupIName, finalBackupIName, ignoreDescriptions(paramInterfacesToDeclare[argType].properties), '\n', ignoreDescriptions(param.properties));
        throw Error(`Interface "${argType}" has already been declared`);
    }
    // Update the params interfaces we still have to define
    paramInterfacesToDeclare[argType] = param;
    paramInterfacesToDeclare[argType].name = argName;
    paramInterfacesToDeclare[argType].tName = argType;
    return maybeArray(argType);
};
const flushParamInterfaces = (API, addToOutput) => {
    const declared = {};
    while (Object.keys(paramInterfacesToDeclare).length > 0) {
        const nestedInterfacesToDeclare = {};
        Object.keys(paramInterfacesToDeclare)
            .sort((a, b) => paramInterfacesToDeclare[a].tName.localeCompare(paramInterfacesToDeclare[b].tName))
            .forEach(paramKey => {
            if (paramKey === 'Event') {
                delete paramInterfacesToDeclare[paramKey];
                return;
            }
            if (declared[paramKey]) {
                const toDeclareCheck = Object.assign({}, paramInterfacesToDeclare[paramKey]);
                const declaredCheck = Object.assign({}, declared[paramKey]);
                for (const prop of ['type', 'collection', 'required', 'description']) {
                    delete toDeclareCheck[prop];
                    delete declaredCheck[prop];
                }
                if (!lodash_1.default.isEqual(toDeclareCheck, declaredCheck)) {
                    throw new Error('Ruh roh, "' + paramKey + '" is already declared');
                }
                delete paramInterfacesToDeclare[paramKey];
                return;
            }
            declared[paramKey] = paramInterfacesToDeclare[paramKey];
            const param = paramInterfacesToDeclare[paramKey];
            const paramAPI = [];
            paramAPI.push(`interface ${lodash_1.default.upperFirst(param.tName)}${param.extends ? ` extends ${param.extends}` : ''} {`);
            param.properties = param.properties || [];
            param.properties.forEach(paramProperty => {
                if (paramProperty.description) {
                    utils.extendArray(paramAPI, utils.wrapComment(paramProperty.description, paramProperty.additionalTags));
                }
                if (!Array.isArray(paramProperty.type) && paramProperty.type.toLowerCase() === 'object') {
                    let argType = paramProperty.__type || lodash_1.default.upperFirst(lodash_1.default.camelCase(paramProperty.name));
                    if (API.some(a => a.name === argType)) {
                        paramProperty.type = argType;
                        debug(chalk_1.default.red(`Auto-correcting type from Object --> ${argType} in Interface: ${lodash_1.default.upperFirst(param.tName)} --- This should be fixed in the docs`));
                    }
                    else {
                        nestedInterfacesToDeclare[argType] = paramProperty;
                        nestedInterfacesToDeclare[argType].name = paramProperty.name;
                        nestedInterfacesToDeclare[argType].tName = argType;
                        paramProperty.type = argType;
                    }
                }
                if (Array.isArray(paramProperty.type)) {
                    paramProperty.type = paramProperty.type.map(paramPropertyType => {
                        const functionProp = paramPropertyType;
                        if (paramPropertyType.type === 'Function' && functionProp.parameters) {
                            return Object.assign({}, paramPropertyType, { 
                                // FIXME: functionProp should slot in here perfectly
                                type: utils.genMethodString(DynamicParamInterfaces, param, functionProp, true) });
                        }
                        else if (typeof paramPropertyType.type === 'string' &&
                            paramPropertyType.type.toLowerCase() === 'object') {
                            let argType = paramProperty.__type || lodash_1.default.upperFirst(lodash_1.default.camelCase(paramProperty.name));
                            if (API.some(a => a.name === argType)) {
                                paramPropertyType.type = argType;
                                debug(chalk_1.default.red(`Auto-correcting type from Object --> ${argType} in Interface: ${lodash_1.default.upperFirst(param.tName)} --- This should be fixed in the docs`));
                            }
                            else {
                                nestedInterfacesToDeclare[argType] = paramPropertyType;
                                nestedInterfacesToDeclare[argType].name = paramProperty.name;
                                nestedInterfacesToDeclare[argType].tName = argType;
                                paramPropertyType.type = argType;
                            }
                        }
                        return paramPropertyType;
                    });
                }
                const isReadonly = (paramProperty.additionalTags || []).includes(docs_parser_1.DocumentationTag.AVAILABILITY_READONLY)
                    ? 'readonly '
                    : '';
                if (!Array.isArray(paramProperty.type) &&
                    paramProperty.type.toLowerCase() === 'function') {
                    // FIXME: functionProp should slot in here perfectly
                    paramAPI.push(`${isReadonly}${paramProperty.name}${utils.isOptional(paramProperty) ? '?' : ''}: ${utils.genMethodString(DynamicParamInterfaces, param, paramProperty, true)};`);
                }
                else {
                    paramAPI.push(`${isReadonly}${paramProperty.name}${utils.isOptional(paramProperty) ? '?' : ''}: ${utils.typify(paramProperty)};`);
                }
            });
            paramAPI.push('}');
            addToOutput(paramAPI.map((l, index) => (index === 0 || index === paramAPI.length - 1 ? l : `  ${l}`)));
            delete paramInterfacesToDeclare[paramKey];
        });
        Object.assign(paramInterfacesToDeclare, nestedInterfacesToDeclare);
    }
    return Object.keys(declared);
};
class DynamicParamInterfaces {
}
DynamicParamInterfaces.createParamInterface = createParamInterface;
DynamicParamInterfaces.flushParamInterfaces = flushParamInterfaces;
exports.DynamicParamInterfaces = DynamicParamInterfaces;
//# sourceMappingURL=dynamic-param-interfaces.js.map