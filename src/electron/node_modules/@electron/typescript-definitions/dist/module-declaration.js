"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const dynamic_param_interfaces_1 = require("./dynamic-param-interfaces");
const utils = __importStar(require("./utils"));
const docs_parser_1 = require("@electron/docs-parser");
const modules = {};
exports.generateModuleDeclaration = (module, index, API) => {
    const moduleAPI = modules[lodash_1.default.upperFirst(module.name)] || [];
    const newModule = !modules[lodash_1.default.upperFirst(module.name)];
    const isStaticVersion = module.type === 'Module' &&
        API.some((tModule, tIndex) => index !== tIndex && tModule.name.toLowerCase() === module.name.toLowerCase());
    const isClass = module.type === 'Class' || isStaticVersion;
    const parentModules = [];
    let parentModule = module;
    while (parentModule && parentModule.extends) {
        parentModule = API.find(m => m.name === parentModule.extends);
        if (parentModule)
            parentModules.push(parentModule);
    }
    // Interface Declaration
    if (newModule) {
        if (module.type !== 'Structure') {
            if (utils.isEmitter(module)) {
                moduleAPI.push(`${isClass ? 'class' : 'interface'} ${lodash_1.default.upperFirst(module.name)} extends ${module.extends ||
                    (module.name === 'remote'
                        ? 'RemoteMainInterface'
                        : isClass
                            ? 'NodeEventEmitter'
                            : 'NodeJS.EventEmitter')} {`);
                moduleAPI.push('', `// Docs: ${module.websiteUrl}`, '');
            }
            else {
                moduleAPI.push(`${isClass ? 'class' : 'interface'} ${lodash_1.default.upperFirst(module.name)} {`);
                moduleAPI.push('', `// Docs: ${module.websiteUrl}`, '');
            }
        }
        else {
            moduleAPI.push(`interface ${lodash_1.default.upperFirst(module.name)}${module.extends ? ` extends ${module.extends}` : ''} {`);
            moduleAPI.push('', `// Docs: ${module.websiteUrl}`, '');
        }
    }
    // Event Declaration
    if (module.type !== 'Element') {
        // To assist with declaration merging we define all parent events in this class too
        lodash_1.default.concat([], module.instanceEvents || [], module.events || [], ...parentModules.map(m => m.events || []), ...parentModules.map(m => m.instanceEvents || []))
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(moduleEvent => {
            utils.extendArray(moduleAPI, utils.wrapComment(moduleEvent.description, moduleEvent.additionalTags));
            let listener = 'Function';
            if (moduleEvent.parameters && moduleEvent.parameters.length) {
                const args = [];
                const indent = lodash_1.default.repeat(' ', moduleEvent.name.length + 29);
                moduleEvent.parameters.forEach((eventListenerArg, index) => {
                    let argString = '';
                    if (eventListenerArg.description) {
                        if (index === 0)
                            argString += `\n${indent}`;
                        argString += utils
                            .wrapComment(eventListenerArg.description)
                            .map((l, i) => `${l}\n${indent}`)
                            .join('');
                    }
                    let argType = null;
                    const objectListenerArg = eventListenerArg;
                    if (eventListenerArg.type === 'Object' &&
                        objectListenerArg.properties &&
                        objectListenerArg.properties.length) {
                        // Check if we have the same structure for a different name
                        argType = dynamic_param_interfaces_1.DynamicParamInterfaces.createParamInterface(objectListenerArg, eventListenerArg.name === 'params'
                            ? lodash_1.default.upperFirst(lodash_1.default.camelCase(moduleEvent.name))
                            : undefined, lodash_1.default.upperFirst(lodash_1.default.camelCase(moduleEvent.name)));
                    }
                    let newType = argType || utils.typify(eventListenerArg);
                    const functionListenerArg = eventListenerArg;
                    if (newType === 'Function') {
                        newType = utils.genMethodString(dynamic_param_interfaces_1.DynamicParamInterfaces, module, functionListenerArg, // FIXME: <--
                        undefined);
                    }
                    args.push(`${argString}${utils.paramify(eventListenerArg.name)}${utils.isOptional(eventListenerArg) ? '?' : ''}: ${newType}`);
                });
                listener = `(${args.join(`,\n${indent}`)}) => void`;
            }
            for (let method of ['on', 'once', 'addListener', 'removeListener']) {
                moduleAPI.push(`${method}(event: '${moduleEvent.name}', listener: ${listener}): this;`);
            }
        });
    }
    // Dom Element Events
    if (module.type === 'Element') {
        if (module.events) {
            module.events.forEach(domEvent => {
                utils.extendArray(moduleAPI, utils.wrapComment(domEvent.description, domEvent.additionalTags));
                let eventType = 'Event';
                if (domEvent.parameters && domEvent.parameters.length) {
                    const fakeObject = {
                        name: 'event',
                        type: 'Object',
                        collection: false,
                        properties: [],
                        extends: 'Event',
                    };
                    domEvent.parameters.forEach((eventListenerProp, index) => {
                        if (eventListenerProp.name === 'result') {
                            eventListenerProp.__type = `${lodash_1.default.upperFirst(lodash_1.default.camelCase(domEvent.name))}Result`;
                        }
                        fakeObject.properties.push(eventListenerProp);
                    });
                    eventType = dynamic_param_interfaces_1.DynamicParamInterfaces.createParamInterface(fakeObject, lodash_1.default.upperFirst(lodash_1.default.camelCase(domEvent.name)));
                }
                for (let method of ['addEventListener', 'removeEventListener']) {
                    moduleAPI.push(`${method}(event: '${domEvent.name}', listener: (event: ${eventType}) => void${method === 'addEventListener' ? ', useCapture?: boolean' : ''}): this;`);
                }
            });
            // original overloads copied from HTMLElement, because they are not inherited
            moduleAPI.push(`addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;`);
            moduleAPI.push(`addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;`);
            moduleAPI.push(`removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;`);
            moduleAPI.push(`removeEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;`);
        }
    }
    const returnsThis = (moduleMethod) => ['on', 'once', 'removeAllListeners', 'removeListener'].includes(moduleMethod.name);
    const addMethod = (moduleMethod, prefix = '') => {
        utils.extendArray(moduleAPI, utils.wrapComment(moduleMethod.description, moduleMethod.additionalTags));
        let returnType = returnsThis(moduleMethod) ? 'this' : 'void';
        if (moduleMethod.returns) {
            returnType = moduleMethod.returns;
            // Account for methods on the process module that return a custom type/structure, we need to reference the Electron namespace to use these types
            if (module.name === 'process' &&
                moduleMethod.returns.type !== 'Object' &&
                typeof moduleMethod.returns.type === 'string' &&
                !utils.isPrimitive(moduleMethod.returns.type) &&
                !utils.isBuiltIn(moduleMethod.returns.type)) {
                returnType = `Electron.${moduleMethod.returns.type}`;
            }
        }
        if (returnType === 'Object' || returnType.type === 'Object') {
            returnType = dynamic_param_interfaces_1.DynamicParamInterfaces.createParamInterface(moduleMethod.returns, lodash_1.default.upperFirst(moduleMethod.name));
            // The process module is not in the Electron namespace so we need to reference the Electron namespace to use these types
            if (module.name === 'process') {
                returnType = `Electron.${returnType}`;
            }
        }
        const paramString = utils.genMethodString(dynamic_param_interfaces_1.DynamicParamInterfaces, module, moduleMethod, false, module.name === 'process' ? 'Electron.' : '');
        moduleAPI.push(`${prefix}${moduleMethod.name}${moduleMethod.rawGenerics || ''}(${paramString})${moduleMethod.name === 'constructor'
            ? ''
            : `: ${utils.typify(returnType, `${lodash_1.default.upperFirst(moduleMethod.name)}ReturnValue`)}`};`);
    };
    // Class constructor
    if (module.constructorMethod) {
        addMethod(Object.assign({ name: 'constructor' }, module.constructorMethod, { description: module.name, returns: null, additionalTags: [] }));
    }
    // Static Method Declaration
    if (module.staticMethods) {
        module.staticMethods
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(m => addMethod(m, 'static '));
    }
    // Method Declaration
    if (module.methods) {
        module.methods
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(m => addMethod(m, isStaticVersion ? 'static ' : ''));
    }
    // Instance Method Declaration
    if (module.instanceMethods) {
        module.instanceMethods.sort((a, b) => a.name.localeCompare(b.name)).forEach(m => addMethod(m));
    }
    // Class properties
    if (module.instanceProperties) {
        module.instanceProperties
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(prop => {
            const isOptional = !prop.required ? '?' : '';
            const isReadonly = prop.additionalTags.includes(docs_parser_1.DocumentationTag.AVAILABILITY_READONLY)
                ? 'readonly '
                : '';
            if (prop.description) {
                utils.extendArray(moduleAPI, utils.wrapComment(prop.description, prop.additionalTags));
            }
            moduleAPI.push(`${isReadonly}${prop.name}${isOptional}: ${utils.typify(prop)};`);
        });
    }
    // Class Static propreties
    if (module.staticProperties) {
        module.staticProperties
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(prop => {
            const isReadonly = prop.additionalTags.includes(docs_parser_1.DocumentationTag.AVAILABILITY_READONLY)
                ? 'readonly '
                : '';
            if (prop.description) {
                utils.extendArray(moduleAPI, utils.wrapComment(prop.description, prop.additionalTags));
            }
            moduleAPI.push(`static ${isReadonly}${prop.name}: ${utils.typify(prop)};`);
        });
    }
    // Structure properties
    const pseudoProperties = module.properties || [];
    if (pseudoProperties.length) {
        pseudoProperties
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach(p => {
            let paramType = p;
            let type = '';
            if (paramType.type === 'Object') {
                type = dynamic_param_interfaces_1.DynamicParamInterfaces.createParamInterface(p, '');
            }
            else if (Array.isArray(paramType.type)) {
                paramType.type = paramType.type.map(t => t.type !== 'Object'
                    ? t
                    : Object.assign({}, t, { type: dynamic_param_interfaces_1.DynamicParamInterfaces.createParamInterface(Object.assign({}, p, { type: t }), '') }));
            }
            const isStatic = isStaticVersion ? 'static ' : '';
            const isOptional = utils.isOptional(p) ? '?' : '';
            const isReadonly = p.additionalTags.includes(docs_parser_1.DocumentationTag.AVAILABILITY_READONLY)
                ? 'readonly '
                : '';
            type = type || utils.typify(paramType);
            utils.extendArray(moduleAPI, utils.wrapComment(p.description, p.additionalTags));
            if (module.name === 'process' && p.name === 'versions')
                return;
            if (p.name.match(/^\d/)) {
                // Wrap key in quotes if it starts with a number, e.g. `2d_canvas`
                moduleAPI.push(`'${isStatic}${isReadonly}${p.name}${isOptional}': ${type};`);
            }
            else {
                moduleAPI.push(`${isStatic}${isReadonly}${p.name}${isOptional}: ${type};`);
            }
        });
    }
    // Save moduleAPI for later reuse
    modules[lodash_1.default.upperFirst(module.name)] = moduleAPI;
};
exports.getModuleDeclarations = () => modules;
//# sourceMappingURL=module-declaration.js.map