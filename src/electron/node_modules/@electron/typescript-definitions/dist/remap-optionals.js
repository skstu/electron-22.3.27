"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils = __importStar(require("./utils"));
const debug_1 = __importDefault(require("debug"));
const chalk_1 = __importDefault(require("chalk"));
const debug = debug_1.default('remap-optionals');
exports.remapOptionals = (API) => {
    API.forEach(module => {
        // Remap optionals to actually be multiple methods when appropriate
        const remap = (attr) => {
            const moreMethods = [];
            const attrs = module[attr] || [];
            attrs.forEach(method => {
                if (!method.parameters)
                    return;
                if (method.__handled)
                    return;
                let optionalFound = false;
                lodash_1.default.concat([], method.parameters).forEach((param, index) => {
                    if (optionalFound && !utils.isOptional(param)) {
                        debug(chalk_1.default.cyan(`Duplicating method due to prefixed optional: ${method.name} Slicing at: ${index}`));
                        moreMethods.push(Object.assign({}, lodash_1.default.cloneDeep(method), {
                            parameters: [...lodash_1.default.cloneDeep(method.parameters)].filter((tParam, pIndex) => {
                                if (pIndex >= index)
                                    return true;
                                return !utils.isOptional(tParam);
                            }),
                        }));
                        for (let i = 0; i < index; i++) {
                            if (method.parameters[i].description) {
                                method.parameters[i].description = method.parameters[i].description.replace(/optional/gi, '');
                            }
                            method.parameters[i].required = true;
                        }
                        method.__handled = true;
                    }
                    optionalFound = optionalFound || utils.isOptional(param);
                });
            });
            attrs.push(...moreMethods);
        };
        remap('methods');
        remap('instanceMethods');
        remap('staticMethods');
    });
};
//# sourceMappingURL=remap-optionals.js.map