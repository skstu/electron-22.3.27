"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const docs_parser_1 = require("@electron/docs-parser");
const lodash_1 = __importDefault(require("lodash"));
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default('utils');
let paramInterfaces;
const lazyParamInterfaces = () => {
    if (!paramInterfaces) {
        paramInterfaces = require('./dynamic-param-interfaces').DynamicParamInterfaces;
    }
    return paramInterfaces;
};
exports.extendArray = (arr1, arr2) => {
    arr1.push(...arr2);
    return arr1;
};
exports.wrapComment = (comment, additionalTags = []) => {
    if (!comment)
        return [];
    comment = comment.replace(/^\(optional\)(?: - )?/gi, '');
    if (!comment)
        return [];
    const result = ['/**'];
    while (comment.length > 0) {
        let index = 0;
        for (let i = 0; i <= 80; i++) {
            if (comment[i] === ' ')
                index = i;
            if (comment[i] === '\n') {
                index = i;
                break;
            }
        }
        if (comment.length <= 80 && !comment.includes('\n')) {
            index = 80;
        }
        result.push(` * ${comment.substring(0, index)}`);
        comment = comment.substring(index + 1);
    }
    if (additionalTags.length) {
        result.push(' *');
        const nodePlatforms = [];
        result.push(...additionalTags
            .map(tag => {
            switch (tag) {
                case docs_parser_1.DocumentationTag.STABILITY_DEPRECATED:
                    return ' * @deprecated';
                case docs_parser_1.DocumentationTag.STABILITY_EXPERIMENTAL:
                    return ' * @experimental';
                case docs_parser_1.DocumentationTag.OS_LINUX:
                    nodePlatforms.push('linux');
                    break;
                case docs_parser_1.DocumentationTag.OS_MACOS:
                    nodePlatforms.push('darwin');
                    break;
                case docs_parser_1.DocumentationTag.OS_MAS:
                    nodePlatforms.push('mas');
                    break;
                case docs_parser_1.DocumentationTag.OS_WINDOWS:
                    nodePlatforms.push('win32');
                    break;
            }
            return '';
        })
            .filter(tag => tag));
        if (nodePlatforms.length) {
            result.push(` * @platform ${nodePlatforms.join(',')}`);
        }
    }
    return result.concat(' */');
};
const prefixTypeForSafety = (type) => {
    if (type !== 'Object' && typeof type === 'string' && !exports.isPrimitive(type) && !exports.isBuiltIn(type)) {
        return `Electron.${type}`;
    }
    return type;
};
exports.typify = (type, maybeInnerReturnTypeName) => {
    // Capture some weird edge cases
    const originalType = type;
    if (!Array.isArray(type) && type.type && typeof type.type === 'object') {
        type = type.type;
    }
    if (Array.isArray(type)) {
        const arrayType = Array.from(new Set(type.map(t => `(${exports.typify(t)})`))).join(' | ');
        if (!Array.isArray(originalType) && originalType.collection) {
            return `Array<${arrayType}>`;
        }
        return arrayType;
    }
    if (!type)
        throw new Error('Missing type provided to typify, something is wrong in the documentation');
    let innerTypes;
    let typeAsString = type;
    if (typeof type === 'object') {
        if (!type.type) {
            console.error(type);
            throw new Error('Missing type property on object provided to typify, something is wrong in the documentation');
        }
        let newType = type.type;
        if (typeof newType === 'string' && newType.toLowerCase() === 'string') {
            const stringType = type;
            if (stringType.possibleValues) {
                const stringEnum = stringType.possibleValues.map(value => `'${value.value}'`).join(' | ');
                if (type.collection) {
                    // Array<foo | bar> syntax instead of (foo | bar)[]
                    newType = `Array<${stringEnum}>`;
                    type.collection = false;
                }
                else {
                    newType = `(${stringEnum})`;
                }
            }
        }
        if (type.innerTypes) {
            innerTypes = type.innerTypes;
            if (type.innerTypes) {
                // Handle one of the innerType being an Object type
                innerTypes = type.innerTypes.map(inner => inner.type === 'Object'
                    ? Object.assign({}, inner, { type: lazyParamInterfaces().createParamInterface(inner, maybeInnerReturnTypeName) }) : inner);
            }
        }
        typeAsString = newType;
    }
    if (type.collection)
        typeAsString += '[]';
    if (typeof typeAsString !== 'string') {
        throw new Error('typeAsString is not a string, something has gone terribly wrong');
    }
    switch (typeAsString.toLowerCase()) {
        case 'double':
        case 'integer':
        case 'float':
            return 'number';
        case 'double[]':
        case 'integer[]':
        case 'float[]':
            return 'number[]';
        case 'array': {
            if (innerTypes)
                return `Array<${exports.typify(innerTypes[0])}>`;
            throw new Error('Untyped "Array" as return type');
        }
        case 'true':
        case 'false':
            throw new Error('"true" or "false" provided as return value, inferring "Boolean" type');
        case '[objects]':
            throw new Error('[Objects] is not a valid array definition, please conform to the styleguide');
        case 'object':
            throw new Error('Unstructured "Object" type specified, you must specify either the type of the object or provide the key structure inline in the documentation');
        case 'any':
            return 'any';
        case 'string':
        case 'boolean':
        case 'number':
        case 'string[]':
        case 'boolean[]':
        case 'number[]':
            return typeAsString.toLowerCase();
        case 'buffer':
            return 'Buffer';
        case 'buffer[]':
            return 'Buffer[]';
        case 'voidfunction':
            return '(() => void)';
        case 'promise':
            if (innerTypes) {
                return `Promise<${prefixTypeForSafety(exports.typify(innerTypes[0]))}>`;
            }
            throw new Error('Promise with missing inner type');
        case 'record':
            if (innerTypes && innerTypes.length === 2) {
                return `Record<${exports.typify(innerTypes[0])}, ${exports.typify(innerTypes[1])}>`;
            }
            throw new Error('Record with missing inner types');
        case 'partial':
            if (!innerTypes || innerTypes.length !== 1) {
                throw new Error('Partial generic type must have exactly one inner type.  i.e. Partial<T>');
            }
            return `Partial<${exports.typify(innerTypes[0])}>`;
        case 'url':
            return 'string';
        case 'touchbaritem':
            return '(TouchBarButton | TouchBarColorPicker | TouchBarGroup | TouchBarLabel | TouchBarPopover | TouchBarScrubber | TouchBarSegmentedControl | TouchBarSlider | TouchBarSpacer | null)';
        case 'readablestream':
            // See StreamProtocolResponse.data which accepts a Node.js readable stream.
            // The ReadableStream type unfortunately conflicts with the ReadableStream interface
            // defined in the Streams standard (https://streams.spec.whatwg.org/#rs-class) so
            // we'll have to qualify it with the Node.js namespace.
            return 'NodeJS.ReadableStream';
    }
    return typeAsString;
};
exports.paramify = (paramName) => {
    switch (paramName.toLowerCase()) {
        case 'switch':
            return 'the_switch';
    }
    return paramName;
};
// TODO: Infer through electron-docs-linter/parser
exports.isEmitter = (module) => {
    const nonEventEmitters = [
        'menu',
        'menuitem',
        'nativeimage',
        'shell',
        'browserview',
        'webrequest',
        'crashreporter',
        'dock',
        'commandline',
        'browserwindowproxy',
        'clipboard',
        'contenttracing',
        'desktopcapturer',
        'dialog',
        'globalshortcut',
        'powersaveblocker',
        'touchbar',
        'touchbarbutton',
        'net',
        'netlog',
        'protocol',
        'contextbridge',
    ];
    return !nonEventEmitters.includes(module.name.toLowerCase());
};
exports.isPrimitive = (type) => {
    const primitives = ['boolean', 'number', 'any', 'string', 'void', 'unknown'];
    return primitives.indexOf(type.toLowerCase().replace(/\[\]/g, '')) !== -1;
};
exports.isBuiltIn = (type) => {
    const builtIns = [
        'promise',
        'buffer',
        'int8array',
        'uint8array',
        'uint8clampedarray',
        'int16array',
        'uint16array',
        'int32array',
        'uint32array',
        'float32array',
        'float64array',
        'bigint64array',
        'biguint64array',
    ];
    return builtIns.indexOf(type.toLowerCase().replace(/\[\]/g, '')) !== -1;
};
exports.isOptional = (param) => {
    // Did we pass a "required"?
    if (typeof param.required !== 'undefined') {
        return !param.required;
    }
    // FIXME: Review this after migration to docs-parser
    // Assume that methods are never optional because electron-docs-linter
    // doesn't currently mark them as required.
    debug(`Could not determine optionality for ${param.name}`);
    return param.type !== 'Function';
};
exports.genMethodString = (paramInterfaces, module, moduleMethod, includeType = true, paramTypePrefix = '', topLevelModuleMethod) => {
    const createMethodObjectParamType = (objectParam) => {
        if ('constructor' === moduleMethod.name.toLowerCase()) {
            objectParam.name = objectParam.name || 'options';
        }
        if (objectParam.name === 'options') {
            if (['show', 'hide', 'open', 'close', 'start', 'stop', 'constructor', 'print'].includes(moduleMethod.name.toLowerCase())) {
                return paramInterfaces.createParamInterface(objectParam, lodash_1.default.upperFirst(module.name) + lodash_1.default.upperFirst(moduleMethod.name));
            }
            return paramInterfaces.createParamInterface(objectParam, lodash_1.default.upperFirst(moduleMethod.name));
        }
        if (['set', 'get'].includes(moduleMethod.name.toLowerCase())) {
            return paramInterfaces.createParamInterface(objectParam, lodash_1.default.upperFirst(module.name) + lodash_1.default.upperFirst(moduleMethod.name));
        }
        return paramInterfaces.createParamInterface(objectParam, '', lodash_1.default.upperFirst(moduleMethod.name), topLevelModuleMethod ? lodash_1.default.upperFirst(topLevelModuleMethod.name) : '');
    };
    return `${includeType ? '(' : ''}${(moduleMethod.parameters || [])
        .map(param => {
        let paramType = param;
        const objectParam = param;
        if (param.type === 'Object' && objectParam.properties && objectParam.properties.length) {
            // Check if we have the same structure for a different name
            paramType = createMethodObjectParamType(objectParam);
        }
        if (Array.isArray(param.type)) {
            param.type = param.type.map(paramType => {
                const functionParam = paramType;
                const objectParam = paramType;
                if (paramType.type === 'Function' && functionParam.parameters) {
                    return Object.assign({}, paramType, {
                        type: exports.genMethodString(paramInterfaces, module, Object.assign({ name: lodash_1.default.upperFirst(moduleMethod.name) + lodash_1.default.upperFirst(param.name) }, functionParam) /* FIXME: */, true, '', moduleMethod),
                    });
                }
                else if (paramType.type === 'Object' && objectParam.properties) {
                    return Object.assign({}, objectParam, { type: createMethodObjectParamType(Object.assign({}, objectParam, { name: param.name })) });
                }
                return paramType;
            });
        }
        const functionParam = param;
        if (param.type === 'Function' && functionParam.parameters) {
            paramType = exports.genMethodString(paramInterfaces, module, functionParam /* FIXME: */, true, '', moduleMethod);
        }
        const name = exports.paramify(param.name);
        const optional = exports.isOptional(param) ? '?' : '';
        // Figure out this parameter's type
        let type;
        const stringParam = param;
        if (stringParam.possibleValues && stringParam.possibleValues.length) {
            type = stringParam.possibleValues.map(v => `'${v.value}'`).join(' | ');
        }
        else {
            type = `${exports.typify(paramType)}${exports.paramify(param.name).startsWith('...') && !exports.typify(paramType).endsWith('[]')
                ? '[]'
                : ''}`;
        }
        if (param.type !== 'Function' && type.substr(0, 1).toLowerCase() !== type.substr(0, 1)) {
            type = paramTypePrefix + type;
        }
        return `${name}${optional}: ${type}`;
    })
        .join(', ')}${includeType ? `) => ${moduleMethod.returns ? exports.typify(moduleMethod.returns) : 'void'}` : ''}`;
};
//# sourceMappingURL=utils.js.map