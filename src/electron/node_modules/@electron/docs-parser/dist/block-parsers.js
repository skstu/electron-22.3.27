"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const markdown_helpers_1 = require("./markdown-helpers");
exports.guessParametersFromSignature = (signature) => {
    chai_1.expect(signature).to.match(/^\(([a-zA-Z,\[\] ]+|(\.\.\.[^\.])|([a-zA-Z][0-9]))+\)$/g, 'signature should be a bracket wrapped group of parameters');
    const justParams = signature.slice(1, signature.length - 1);
    let optionalDepth = 0;
    const params = [];
    let currentParam = '';
    let currentOptional = false;
    const maybePushCurrent = () => {
        const trimmed = currentParam.trim();
        if (trimmed) {
            params.push({
                name: trimmed,
                optional: currentOptional,
            });
            currentParam = '';
        }
    };
    for (let i = 0; i < justParams.length; i++) {
        const char = justParams[i];
        switch (char) {
            case '[':
                optionalDepth++;
                break;
            case ']':
                maybePushCurrent();
                optionalDepth--;
                chai_1.expect(optionalDepth).to.be.gte(0, `optional depth should never be negative, you have too many "]" characters in your signature: "${signature}"`);
                break;
            case ',':
                maybePushCurrent();
                break;
            default:
                if (!currentParam.trim())
                    currentOptional = optionalDepth > 0;
                currentParam += char;
        }
    }
    maybePushCurrent();
    chai_1.expect(optionalDepth).to.equal(0, `optional depth should return to 0, you have mismateched [ and ] characters in your signature: "${signature}"`);
    return params;
};
exports._headingToMethodBlock = (heading) => {
    if (!heading)
        return null;
    const methodStringWithGenericRegexp = /`(?:.+\.)?(.+?)(<.+>)(\(.*?\))`((?: _[^_]+?_)*)/g;
    const methodStringRegexp = /`(?:.+\.)?(.+?)(\(.*?\))`((?: _[^_]+?_)*)/g;
    const methodStringWithGenericMatch = methodStringWithGenericRegexp.exec(heading.heading);
    const methodStringMatch = methodStringRegexp.exec(heading.heading);
    methodStringRegexp.lastIndex = -1;
    methodStringWithGenericRegexp.lastIndex = -1;
    chai_1.expect(heading.heading).to.match(methodStringRegexp, 'each method should have a code blocked method name');
    let methodString;
    let methodGenerics = '';
    let methodSignature;
    let headingTags;
    if (methodStringWithGenericMatch) {
        [, methodString, methodGenerics, methodSignature, headingTags] = methodStringWithGenericMatch;
    }
    else {
        [, methodString, methodSignature, headingTags] = methodStringMatch;
    }
    let parameters = [];
    if (methodSignature !== '()') {
        const guessedParams = exports.guessParametersFromSignature(methodSignature);
        // If we have parameters we need to find the list of typed keys
        const list = markdown_helpers_1.findNextList(heading.content);
        chai_1.expect(list).to.not.equal(null, `Method ${heading.heading} has at least one parameter but no parameter type list`);
        parameters = markdown_helpers_1.consumeTypedKeysList(markdown_helpers_1.convertListToTypedKeys(list)).map(typedKey => (Object.assign({ name: typedKey.key, description: typedKey.description, required: typedKey.required }, typedKey.type)));
        chai_1.expect(parameters).to.have.lengthOf(guessedParams.length, `should have the same number of documented parameters as we have in the method signature: "${methodSignature}"`);
        for (let i = 0; i < parameters.length; i++) {
            chai_1.expect(parameters[i].required).to.equal(!guessedParams[i].optional, `the optionality of a parameter in the signature should match the documented optionality in the parameter description: "${methodString}${methodSignature}", while parsing parameter: "${parameters[i].name}"`);
        }
    }
    const returnTokens = methodSignature === '()'
        ? markdown_helpers_1.findContentAfterHeadingClose(heading.content)
        : markdown_helpers_1.findContentAfterList(heading.content, true);
    const { parsedDescription, parsedReturnType } = markdown_helpers_1.extractReturnType(returnTokens);
    return {
        name: methodString,
        signature: methodSignature,
        description: parsedDescription,
        rawGenerics: methodGenerics || undefined,
        parameters,
        returns: parsedReturnType,
        additionalTags: markdown_helpers_1.parseHeadingTags(headingTags),
        urlFragment: `#${markdown_helpers_1.slugifyHeading(heading.heading)}`,
    };
};
exports._headingToPropertyBlock = (heading) => {
    const propertyStringRegexp = /`(?:.+\.)?(.+?)`((?: _[^_]+?_)*)/g;
    const propertyStringMatch = propertyStringRegexp.exec(heading.heading);
    propertyStringRegexp.lastIndex = -1;
    chai_1.expect(heading.heading).to.match(propertyStringRegexp, 'each property should have a code blocked property name');
    const [, propertyString, headingTags] = propertyStringMatch;
    const { parsedDescription, parsedReturnType } = markdown_helpers_1.extractReturnType(markdown_helpers_1.findContentAfterHeadingClose(heading.content), markdown_helpers_1.StripReturnTypeBehavior.DO_NOT_STRIP, 'An?');
    chai_1.expect(parsedReturnType).to.not.equal(null, `Property ${heading.heading} should have a declared type but it does not`);
    return Object.assign({ name: propertyString, description: parsedDescription, required: !/\(optional\)/i.test(parsedDescription), additionalTags: markdown_helpers_1.parseHeadingTags(headingTags), urlFragment: `#${markdown_helpers_1.slugifyHeading(heading.heading)}` }, parsedReturnType);
};
exports._headingToEventBlock = (heading) => {
    const eventNameRegexp = /^Event: '(.+)'((?: _[^_]+?_)*)/g;
    const eventNameMatch = eventNameRegexp.exec(heading.heading);
    eventNameRegexp.lastIndex = -1;
    chai_1.expect(heading.heading).to.match(eventNameRegexp, 'each event should have a quoted event name');
    const [, eventName, headingTags] = eventNameMatch;
    chai_1.expect(eventName).to.not.equal('', 'should have a non-zero-length event name');
    const description = markdown_helpers_1.safelyJoinTokens(markdown_helpers_1.findContentAfterList(heading.content, true));
    let parameters = [];
    if (markdown_helpers_1.safelyJoinTokens(markdown_helpers_1.findContentAfterHeadingClose(heading.content))
        .trim()
        .startsWith('Returns:')) {
        const list = markdown_helpers_1.findNextList(heading.content);
        if (list) {
            parameters = markdown_helpers_1.consumeTypedKeysList(markdown_helpers_1.convertListToTypedKeys(list)).map(typedKey => (Object.assign(Object.assign({ name: typedKey.key, description: typedKey.description }, typedKey.type), { required: true })));
        }
    }
    return {
        name: eventName,
        description,
        parameters,
        additionalTags: markdown_helpers_1.parseHeadingTags(headingTags),
        urlFragment: `#${markdown_helpers_1.slugifyHeading(heading.heading)}`,
    };
};
exports.parseMethodBlocks = (tokens) => {
    if (!tokens)
        return [];
    return markdown_helpers_1.headingsAndContent(tokens).map(heading => exports._headingToMethodBlock(heading));
};
exports.parsePropertyBlocks = (tokens) => {
    if (!tokens)
        return [];
    return markdown_helpers_1.headingsAndContent(tokens).map(exports._headingToPropertyBlock);
};
exports.parseEventBlocks = (tokens) => {
    if (!tokens)
        return [];
    return markdown_helpers_1.headingsAndContent(tokens).map(exports._headingToEventBlock);
};
//# sourceMappingURL=block-parsers.js.map