"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = __importStar(require("fs-extra"));
const markdown_it_1 = __importDefault(require("markdown-it"));
const path = __importStar(require("path"));
const toCamelCase = require("lodash.camelcase");
const ParsedDocumentation_1 = require("./ParsedDocumentation");
const markdown_helpers_1 = require("./markdown-helpers");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
const block_parsers_1 = require("./block-parsers");
class DocsParser {
    constructor(baseElectronDir, moduleVersion, apiFiles, structureFiles, packageMode) {
        this.baseElectronDir = baseElectronDir;
        this.moduleVersion = moduleVersion;
        this.apiFiles = apiFiles;
        this.structureFiles = structureFiles;
        this.packageMode = packageMode;
    }
    parseBaseContainers(filePath, fileContents, tokens) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure POSIX-style path separators regardless of OS
            const relativeDocsPath = path
                .relative(this.baseElectronDir, filePath)
                .split(path.sep)
                .join(path.posix.sep)
                .split('.')[0];
            const isStructure = relativeDocsPath.includes('structures');
            const headings = markdown_helpers_1.headingsAndContent(tokens);
            chai_1.expect(headings).to.not.have.lengthOf(0, `File "${filePath}" does not have a top level heading, this is required`);
            const parsedContainers = [];
            for (const heading of headings) {
                const isTopLevelModuleHeading = heading.level === 1 && parsedContainers.length === 0;
                const isSecondLevelClassHeading = heading.level === 2 && heading.heading.startsWith('Class: ');
                const isClass = isSecondLevelClassHeading && !isTopLevelModuleHeading;
                if (isTopLevelModuleHeading && heading.heading.endsWith('(Draft)')) {
                    continue;
                }
                if (isTopLevelModuleHeading || isSecondLevelClassHeading) {
                    let name = heading.heading;
                    if (isStructure) {
                        chai_1.expect(name).to.match(/ Object(?: extends `.+?`)?$/, 'Structure doc files top level heading should end with " Object"');
                        // Remove " Object"
                        name = name.replace(/ Object(?: extends `.+?`)?$/, '');
                    }
                    else if (isClass) {
                        // Remove "Class: " and " extends `yyy`"
                        name = name.substr(7).replace(/ extends `.+?`$/, '');
                    }
                    let description = '';
                    if (isStructure) {
                        description = markdown_helpers_1.safelyJoinTokens(markdown_helpers_1.findContentAfterList(tokens));
                    }
                    else {
                        let groups;
                        if (isClass) {
                            groups = markdown_helpers_1.getContentBeforeConstructor(tokens);
                        }
                        else {
                            // FIXME: Make it so that we don't need this magic FIXME for the electron breaking-changes document
                            groups = markdown_helpers_1.getContentBeforeFirstHeadingMatching(tokens, heading => ['Events', 'Methods', 'Properties', '`FIXME` comments'].includes(heading.trim()));
                        }
                        description = groups
                            .map((group, index) => {
                            const inner = markdown_helpers_1.safelyJoinTokens(markdown_helpers_1.findContentAfterHeadingClose(group.content), {
                                parseCodeFences: true,
                            });
                            if (index !== 0) {
                                return `### ${group.heading}\n\n${inner}`;
                            }
                            return inner;
                        })
                            .join('\n\n');
                    }
                    const extendsPattern = isClass ? / extends `(.+?)`?$/ : / Object extends `(.+?)`?$/;
                    const extendsMatch = extendsPattern.exec(heading.heading);
                    parsedContainers.push({
                        isClass,
                        tokens: heading.content,
                        container: {
                            name,
                            extends: extendsMatch ? extendsMatch[1] : undefined,
                            description,
                            slug: path.basename(filePath, '.md'),
                            websiteUrl: `${constants_1.WEBSITE_BASE_DOCS_URL}/${relativeDocsPath}`,
                            repoUrl: `${constants_1.REPO_BASE_DOCS_URL(this.moduleVersion)}/${relativeDocsPath}.md`,
                            version: this.moduleVersion,
                        },
                    });
                }
            }
            return parsedContainers;
        });
    }
    parseAPIFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsed = [];
            const contents = yield fs.readFile(filePath, 'utf8');
            const md = new markdown_it_1.default();
            const allTokens = md.parse(contents, {});
            const baseInfos = yield this.parseBaseContainers(filePath, contents, allTokens);
            let lastModule = null;
            for (const { container, tokens, isClass } of baseInfos) {
                let isElement = false;
                if (container.name.endsWith('` Tag')) {
                    chai_1.expect(container.name).to.match(/<.+?>/g, 'element documentation header should contain the HTML tag');
                    container.name = `${/<(.+?)>/g.exec(container.name)[1]}Tag`;
                    container.extends = 'HTMLElement';
                    isElement = true;
                    chai_1.expect(isClass).to.equal(false, 'HTMLElement documentation should not be considered a class');
                }
                const electronProcess = markdown_helpers_1.findProcess(tokens);
                if (isClass) {
                    // Instance name will be taken either from an example in a method declaration or the camel
                    // case version of the class name
                    const levelFourHeader = markdown_helpers_1.headingsAndContent(tokens).find(h => h.level === 4);
                    const instanceName = levelFourHeader
                        ? (levelFourHeader.heading.split('`')[1] || '').split('.')[0] ||
                            toCamelCase(container.name)
                        : toCamelCase(container.name);
                    // Try to get the constructor method
                    const constructorMethod = block_parsers_1._headingToMethodBlock(markdown_helpers_1.findConstructorHeader(tokens));
                    // This is a class
                    parsed.push(Object.assign(Object.assign({}, container), { type: 'Class', process: electronProcess, constructorMethod: constructorMethod
                            ? {
                                signature: constructorMethod.signature,
                                parameters: constructorMethod.parameters,
                            }
                            : null, 
                        // ### Static Methods
                        staticMethods: block_parsers_1.parseMethodBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Static Methods', 3)), 
                        // ### Static Properties
                        staticProperties: block_parsers_1.parsePropertyBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Static Properties', 3)), 
                        // ### Instance Methods
                        instanceMethods: block_parsers_1.parseMethodBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Instance Methods', 3)), 
                        // ### Instance Properties
                        instanceProperties: block_parsers_1.parsePropertyBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Instance Properties', 3)), 
                        // ### Instance Events
                        instanceEvents: block_parsers_1.parseEventBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Instance Events', 3)), instanceName }));
                    // If we're inside a module, pop off the class and put it in the module as an exported class
                    // Only do this in "multi package" mode as when we are in a single package mode everything is exported at the
                    // top level.  In multi-package mode things are exported under each module so we need the nesting to be correct
                    if (this.packageMode === 'multi' && lastModule)
                        lastModule.exportedClasses.push(parsed.pop());
                }
                else {
                    // This is a module
                    if (isElement) {
                        parsed.push(Object.assign(Object.assign({}, container), { type: 'Element', process: electronProcess, 
                            // ## Methods
                            methods: block_parsers_1.parseMethodBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Methods', 2)), 
                            // ## Properties
                            properties: block_parsers_1.parsePropertyBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Tag Attributes', 2)), 
                            // ## Events
                            events: block_parsers_1.parseEventBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'DOM Events', 2)) }));
                    }
                    else {
                        parsed.push(Object.assign(Object.assign({}, container), { type: 'Module', process: electronProcess, 
                            // ## Methods
                            methods: block_parsers_1.parseMethodBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Methods', 2)), 
                            // ## Properties
                            properties: block_parsers_1.parsePropertyBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Properties', 2)), 
                            // ## Events
                            events: block_parsers_1.parseEventBlocks(markdown_helpers_1.findContentInsideHeader(tokens, 'Events', 2)), 
                            // ## Class: MyClass
                            exportedClasses: [] }));
                        lastModule = parsed[parsed.length - 1];
                    }
                }
            }
            return parsed;
        });
    }
    parseStructure(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yield fs.readFile(filePath, 'utf8');
            const md = new markdown_it_1.default();
            const tokens = md.parse(contents, {});
            const baseInfos = yield this.parseBaseContainers(filePath, contents, tokens);
            chai_1.expect(baseInfos).to.have.lengthOf(1, 'struct files should only contain one structure per file');
            const list = markdown_helpers_1.findNextList(baseInfos[0].tokens);
            chai_1.expect(list).to.not.equal(null, `Structure file ${filePath} has no property list`);
            return Object.assign(Object.assign({ type: 'Structure' }, baseInfos[0].container), { properties: markdown_helpers_1.consumeTypedKeysList(markdown_helpers_1.convertListToTypedKeys(list)).map(typedKey => (Object.assign({ name: typedKey.key, description: typedKey.description, required: typedKey.required, additionalTags: typedKey.additionalTags }, typedKey.type))) });
        });
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = new ParsedDocumentation_1.ParsedDocumentation();
            for (const apiFile of this.apiFiles) {
                try {
                    docs.addModuleOrClassOrElement(...(yield this.parseAPIFile(apiFile)));
                }
                catch (err) {
                    throw helpers_1.extendError(`An error occurred while processing: "${apiFile}"`, err);
                }
            }
            for (const structureFile of this.structureFiles) {
                try {
                    docs.addStructure(yield this.parseStructure(structureFile));
                }
                catch (err) {
                    throw helpers_1.extendError(`An error occurred while processing: "${structureFile}"`, err);
                }
            }
            return docs.getJSON();
        });
    }
}
exports.DocsParser = DocsParser;
//# sourceMappingURL=DocsParser.js.map