import Token from 'markdown-it/lib/token';
import { TypeInformation, PossibleStringValue, DocumentationTag, ProcessBlock } from './ParsedDocumentation';
export declare const parseHeadingTags: (tags: string | null) => DocumentationTag[];
export declare const findNextList: (tokens: Token[]) => Token[] | null;
export declare const findFirstHeading: (tokens: Token[]) => Token;
export declare const findContentAfterList: (tokens: Token[], returnAllOnNoList?: boolean) => Token[];
export declare const findContentAfterHeadingClose: (tokens: Token[]) => Token[];
export declare type HeadingContent = {
    heading: string;
    level: number;
    headingTokens: Token[];
    content: Token[];
};
export declare const headingsAndContent: (tokens: Token[]) => HeadingContent[];
export declare const findConstructorHeader: (tokens: Token[]) => HeadingContent | null;
export declare const getContentBeforeConstructor: (tokens: Token[]) => HeadingContent[];
export declare const getContentBeforeFirstHeadingMatching: (tokens: Token[], matcher: (heading: string) => boolean) => HeadingContent[];
export declare const findContentInsideHeader: (tokens: Token[], expectedHeader: string, expectedLevel: number) => Token[] | null;
export declare const safelySeparateTypeStringOn: (typeString: string, targetChar: string) => string[];
export declare const getTopLevelMultiTypes: (typeString: string) => string[];
export declare const getTopLevelOrderedTypes: (typeString: string) => string[];
/**
 * @param typeString A type as a raw string
 *
 * @returns Either null or the isolated outer/generic types
 *
 * This method is used to extract the highest level generic from a type string.
 * Examples:
 *
 * - `Foo` --> `null`
 * - `Foo<T>` --> `{Foo, T}`
 * - `Foo<T<B, C>>` --> `{Foo, T<B, C>}`
 *
 * The caller is responsible for recursively parsing the generic
 */
export declare const getTopLevelGenericType: (typeString: string) => {
    outerType: string;
    genericType: string;
} | null;
export declare const rawTypeToTypeInformation: (rawType: string, relatedDescription: string, subTypedKeys: TypedKeyList | null) => TypeInformation;
export declare enum StripReturnTypeBehavior {
    STRIP = 0,
    DO_NOT_STRIP = 1
}
export declare const extractStringEnum: (description: string) => PossibleStringValue[] | null;
export declare const extractReturnType: (tokens: Token[], stripTypeFromDescription?: StripReturnTypeBehavior, prefix?: string) => {
    parsedDescription: string;
    parsedReturnType: ({
        collection: boolean;
    } & import("./ParsedDocumentation").DetailedStringType & {
        innerTypes?: TypeInformation[] | undefined;
    }) | ({
        collection: boolean;
    } & {
        type: TypeInformation[];
    } & {
        innerTypes?: TypeInformation[] | undefined;
    }) | ({
        collection: boolean;
    } & import("./ParsedDocumentation").DetailedFunctionType & {
        innerTypes?: TypeInformation[] | undefined;
    }) | ({
        collection: boolean;
    } & import("./ParsedDocumentation").DetailedObjectType & {
        innerTypes?: TypeInformation[] | undefined;
    }) | ({
        collection: boolean;
    } & {
        type: string;
    } & {
        innerTypes?: TypeInformation[] | undefined;
    }) | null;
};
export interface JoinTokenOptions {
    parseCodeFences?: boolean;
}
export declare const safelyJoinTokens: (tokens: Token[], options?: JoinTokenOptions) => string;
declare type TypedKey = {
    key: string;
    type: TypeInformation;
    description: string;
    required: boolean;
    additionalTags: DocumentationTag[];
};
declare type TypedKeyList = {
    keys: TypedKey[];
    consumed: boolean;
};
export declare const consumeTypedKeysList: (list: TypedKeyList) => TypedKey[];
export declare const convertListToTypedKeys: (listTokens: Token[]) => TypedKeyList;
export declare const findProcess: (tokens: Token[]) => ProcessBlock;
export declare const slugifyHeading: (heading: string) => string;
export {};
